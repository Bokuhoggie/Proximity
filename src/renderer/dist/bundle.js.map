{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD,cAAc,uCAAuC;AACrD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D,oCAAoC,UAAU;AAC9C,+BAA+B,aAAa;AAC5C,8BAA8B;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,oEAAoE,4BAA4B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,6CAA6C,UAAU,SAAS,uBAAuB,QAAQ,kBAAkB,QAAQ,oBAAoB;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA;AACA,8DAA8D,4BAA4B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,OAAO,GAAG,gEAAgE;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,KAAK,GAAG,gEAAgE;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,sEAAsE,8BAA8B;AACpG;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa,WAAW,cAAc;AAChF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW,QAAQ,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACz9BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtEA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;AC3iBA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wBAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7HA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2DAA2D,SAAS;AACpE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,yDAAyD;AAChF,qBAAqB,qDAAqD;AAC1E,oBAAoB,mDAAmD;AACvE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,GAAG,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU,KAAK,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA,6EAA6E,OAAO,GAAG,WAAW;AAClG;AACA;AACA;AACA,UAAU;AACV;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,WAAW;AAClG;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oFAAoF,iBAAiB;AACrG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sFAAsF,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAA2C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU;AAC7E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gEAAgE,UAAU;AAC1E;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,KAAK,QAAQ;AACvD;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UChmBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNA;AACgE;AAClB;AACS;AACI;AACD;AACN;AACY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAiB;AACtD,6BAA6B,uDAAS;AACtC,gCAAgC,gEAAY;AAC5C,mCAAmC,yEAAe;AAClD,iCAAiC,mEAAa;AAC9C,+BAA+B,6DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,6CAA6C,yEAAiB;AAC9D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,MAAM;AACrF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oEAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,MAAM;AACzF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc;AACvF,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA,SAAS;AACT;AACA;AACA,8BAA8B,aAAa;AAC3C,+BAA+B,cAAc;AAC7C,sCAAsC,iBAAiB;AACvD;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,WAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,cAAc,GAAG,WAAW;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,cAAc,GAAG,WAAW;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,C","sources":["webpack://proximity/./src/renderer/js/audio/AudioManager.js","webpack://proximity/./src/renderer/js/chat/ChatManager.js","webpack://proximity/./src/renderer/js/core/ConnectionManager.js","webpack://proximity/./src/renderer/js/proximity/ProximityMap.js","webpack://proximity/./src/renderer/js/server/ServerManager.js","webpack://proximity/./src/renderer/js/settings/SettingsManager.js","webpack://proximity/./src/renderer/js/ui/UIManager.js","webpack://proximity/webpack/bootstrap","webpack://proximity/webpack/runtime/define property getters","webpack://proximity/webpack/runtime/hasOwnProperty shorthand","webpack://proximity/webpack/runtime/make namespace object","webpack://proximity/./src/renderer/js/app.js"],"sourcesContent":["// src/renderer/js/audio/AudioManager.js - ACTUALLY Fixed microphone initialization and WebRTC\r\nexport class AudioManager {\r\n    constructor() {\r\n        this.peerConnections = new Map();\r\n        this.localStream = null;\r\n        this.isMuted = false;\r\n        this.initialized = false;\r\n        this.audioContext = null;\r\n        this.micSource = null;\r\n        this.gainNode = null;\r\n        this.analyser = null;\r\n        this.dataArray = null;\r\n        this.volumeCallbacks = [];\r\n        this.persistentVisualizerActive = false;\r\n        this.persistentVisualizerCallback = null;\r\n        this.initializationAttempts = 0;\r\n        this.maxInitAttempts = 3;\r\n        \r\n        this.iceServers = [\r\n            { urls: 'stun:stun.l.google.com:19302' },\r\n            { urls: 'stun:stun1.l.google.com:19302' },\r\n            { urls: 'stun:stun2.l.google.com:19302' }\r\n        ];\r\n    }\r\n\r\n    async initialize() {\r\n        this.initializationAttempts++;\r\n        \r\n        try {\r\n            console.log(`üé§ [ATTEMPT ${this.initializationAttempts}] Initializing audio...`);\r\n            \r\n            // Force close any existing audio context first\r\n            if (this.audioContext && this.audioContext.state !== 'closed') {\r\n                await this.audioContext.close();\r\n                console.log('üîÑ Closed existing audio context');\r\n            }\r\n            \r\n            // Stop any existing stream\r\n            if (this.localStream) {\r\n                this.localStream.getTracks().forEach(track => {\r\n                    console.log('üõë Stopping existing track:', track.label);\r\n                    track.stop();\r\n                });\r\n                this.localStream = null;\r\n            }\r\n            \r\n            console.log('üéØ Requesting microphone access...');\r\n            \r\n            // More aggressive microphone constraints\r\n            const constraints = {\r\n                audio: {\r\n                    echoCancellation: true,\r\n                    noiseSuppression: true,\r\n                    autoGainControl: true,\r\n                    sampleRate: { ideal: 48000, min: 16000 },\r\n                    channelCount: { ideal: 1 },\r\n                    latency: { ideal: 0.01 },\r\n                    volume: { ideal: 1.0 }\r\n                },\r\n                video: false\r\n            };\r\n\r\n            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n            console.log('‚úÖ Microphone access granted!');\r\n            console.log('üìä Stream details:', {\r\n                id: this.localStream.id,\r\n                active: this.localStream.active,\r\n                tracks: this.localStream.getTracks().length\r\n            });\r\n            \r\n            // Verify and log all audio tracks\r\n            const audioTracks = this.localStream.getAudioTracks();\r\n            console.log(`üéµ Found ${audioTracks.length} audio track(s):`);\r\n            \r\n            if (audioTracks.length === 0) {\r\n                throw new Error('‚ùå No audio tracks found in stream');\r\n            }\r\n            \r\n            audioTracks.forEach((track, index) => {\r\n                console.log(`üéµ Track ${index + 1}:`, {\r\n                    label: track.label || 'Unknown Device',\r\n                    enabled: track.enabled,\r\n                    muted: track.muted,\r\n                    readyState: track.readyState,\r\n                    kind: track.kind,\r\n                    constraints: track.getConstraints(),\r\n                    settings: track.getSettings()\r\n                });\r\n                \r\n                // Add event listeners to track\r\n                track.addEventListener('ended', () => {\r\n                    console.warn('‚ö†Ô∏è Audio track ended unexpectedly');\r\n                });\r\n                \r\n                track.addEventListener('mute', () => {\r\n                    console.warn('‚ö†Ô∏è Audio track muted');\r\n                });\r\n                \r\n                track.addEventListener('unmute', () => {\r\n                    console.log('üîä Audio track unmuted');\r\n                });\r\n            });\r\n            \r\n            // Create new audio context with optimal settings\r\n            const AudioContextClass = window.AudioContext || window.webkitAudioContext;\r\n            this.audioContext = new AudioContextClass({\r\n                sampleRate: 48000,\r\n                latencyHint: 'interactive'\r\n            });\r\n            \r\n            console.log('üéõÔ∏è AudioContext created:', {\r\n                state: this.audioContext.state,\r\n                sampleRate: this.audioContext.sampleRate,\r\n                baseLatency: this.audioContext.baseLatency,\r\n                outputLatency: this.audioContext.outputLatency\r\n            });\r\n            \r\n            // Resume audio context if suspended (required by browser autoplay policies)\r\n            if (this.audioContext.state === 'suspended') {\r\n                console.log('‚ñ∂Ô∏è Resuming suspended audio context...');\r\n                await this.audioContext.resume();\r\n                console.log('‚úÖ Audio context resumed, state:', this.audioContext.state);\r\n            }\r\n            \r\n            // Create audio processing nodes\r\n            this.gainNode = this.audioContext.createGain();\r\n            this.gainNode.gain.setValueAtTime(1.0, this.audioContext.currentTime);\r\n            \r\n            this.analyser = this.audioContext.createAnalyser();\r\n            this.analyser.fftSize = 512; // Increased for better analysis\r\n            this.analyser.smoothingTimeConstant = 0.3; // Less smoothing for more responsive\r\n            this.analyser.minDecibels = -90;\r\n            this.analyser.maxDecibels = -10;\r\n            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n            \r\n            console.log('üîß Audio nodes created:', {\r\n                gainValue: this.gainNode.gain.value,\r\n                analyserFFTSize: this.analyser.fftSize,\r\n                frequencyBinCount: this.analyser.frequencyBinCount\r\n            });\r\n            \r\n            // Connect audio pipeline\r\n            this.micSource = this.audioContext.createMediaStreamSource(this.localStream);\r\n            this.micSource.connect(this.gainNode);\r\n            this.gainNode.connect(this.analyser);\r\n            \r\n            console.log('üîó Audio pipeline connected successfully');\r\n            \r\n            // Start immediate audio testing\r\n            this.startVolumeAnalysis();\r\n            this.testAudioInputImmediate();\r\n            \r\n            this.initialized = true;\r\n            this.initializationAttempts = 0; // Reset on success\r\n            \r\n            console.log('üéâ Audio initialization SUCCESSFUL!');\r\n            \r\n            // Notify success\r\n            if (window.proximityApp?.uiManager) {\r\n                window.proximityApp.uiManager.showNotification('üé§ Microphone initialized successfully!', 'success');\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error(`‚ùå Audio initialization failed (attempt ${this.initializationAttempts}):`, error);\r\n            \r\n            this.initialized = false;\r\n            \r\n            // Try again with fallback constraints if first attempt\r\n            if (this.initializationAttempts < this.maxInitAttempts) {\r\n                console.log('üîÑ Retrying with fallback constraints...');\r\n                await this.delay(1000);\r\n                return this.initializeWithFallback();\r\n            }\r\n            \r\n            // Provide specific error messages\r\n            let errorMessage = 'Failed to access microphone: ';\r\n            \r\n            if (error.name === 'NotAllowedError') {\r\n                errorMessage += 'Permission denied. Please allow microphone access and try again.';\r\n            } else if (error.name === 'NotFoundError') {\r\n                errorMessage += 'No microphone found. Please connect a microphone and try again.';\r\n            } else if (error.name === 'NotReadableError') {\r\n                errorMessage += 'Microphone is already in use by another application.';\r\n            } else if (error.name === 'OverconstrainedError') {\r\n                errorMessage += 'Microphone constraints not supported. Trying fallback...';\r\n                return this.initializeWithFallback();\r\n            } else {\r\n                errorMessage += error.message;\r\n            }\r\n            \r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n\r\n    async initializeWithFallback() {\r\n        console.log('üîÑ Attempting fallback initialization...');\r\n        \r\n        try {\r\n            // Very basic constraints as fallback\r\n            const fallbackConstraints = {\r\n                audio: true,\r\n                video: false\r\n            };\r\n\r\n            this.localStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);\r\n            console.log('‚úÖ Fallback microphone access granted!');\r\n            \r\n            // Setup basic audio context\r\n            const AudioContextClass = window.AudioContext || window.webkitAudioContext;\r\n            this.audioContext = new AudioContextClass();\r\n            \r\n            if (this.audioContext.state === 'suspended') {\r\n                await this.audioContext.resume();\r\n            }\r\n            \r\n            this.gainNode = this.audioContext.createGain();\r\n            this.gainNode.gain.value = 1.0;\r\n            \r\n            this.analyser = this.audioContext.createAnalyser();\r\n            this.analyser.fftSize = 256;\r\n            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n            \r\n            this.micSource = this.audioContext.createMediaStreamSource(this.localStream);\r\n            this.micSource.connect(this.gainNode);\r\n            this.gainNode.connect(this.analyser);\r\n            \r\n            this.startVolumeAnalysis();\r\n            this.testAudioInputImmediate();\r\n            \r\n            this.initialized = true;\r\n            console.log('üéâ Fallback audio initialization successful!');\r\n            \r\n            if (window.proximityApp?.uiManager) {\r\n                window.proximityApp.uiManager.showNotification('üé§ Microphone initialized with basic settings', 'warning');\r\n            }\r\n            \r\n        } catch (fallbackError) {\r\n            console.error('‚ùå Fallback initialization also failed:', fallbackError);\r\n            throw new Error('Failed to initialize microphone with any settings: ' + fallbackError.message);\r\n        }\r\n    }\r\n\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    testAudioInputImmediate() {\r\n        console.log('üß™ Starting immediate audio input test...');\r\n        \r\n        if (!this.analyser || !this.dataArray) {\r\n            console.warn('‚ö†Ô∏è Audio analyser not available for testing');\r\n            return;\r\n        }\r\n        \r\n        let testCount = 0;\r\n        let maxLevel = 0;\r\n        let totalLevel = 0;\r\n        const maxTests = 100; // Test for ~2 seconds\r\n        \r\n        const testInterval = setInterval(() => {\r\n            this.analyser.getByteFrequencyData(this.dataArray);\r\n            \r\n            // Calculate both frequency average and time domain\r\n            const freqAverage = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;\r\n            \r\n            // Also check time domain for more accurate voice detection\r\n            const timeDataArray = new Uint8Array(this.analyser.fftSize);\r\n            this.analyser.getByteTimeDomainData(timeDataArray);\r\n            \r\n            let sum = 0;\r\n            for (let i = 0; i < timeDataArray.length; i++) {\r\n                const sample = (timeDataArray[i] - 128) / 128;\r\n                sum += sample * sample;\r\n            }\r\n            const rms = Math.sqrt(sum / timeDataArray.length);\r\n            const volume = rms * 100;\r\n            \r\n            maxLevel = Math.max(maxLevel, freqAverage, volume);\r\n            totalLevel += freqAverage;\r\n            \r\n            if (testCount % 20 === 0) { // Log every 20th test\r\n                console.log(`üéØ Audio test ${testCount}: freq=${freqAverage.toFixed(2)}, rms=${volume.toFixed(2)}, max=${maxLevel.toFixed(2)}`);\r\n            }\r\n            \r\n            testCount++;\r\n            if (testCount >= maxTests) {\r\n                clearInterval(testInterval);\r\n                const averageLevel = totalLevel / maxTests;\r\n                \r\n                console.log('üìä Audio test results:', {\r\n                    maxLevel: maxLevel.toFixed(2),\r\n                    averageLevel: averageLevel.toFixed(2),\r\n                    testDuration: `${maxTests * 20}ms`,\r\n                    verdict: maxLevel > 1 ? '‚úÖ WORKING' : '‚ùå NO INPUT DETECTED'\r\n                });\r\n                \r\n                if (maxLevel > 1) {\r\n                    console.log('üéâ Microphone input is working properly!');\r\n                } else {\r\n                    console.warn('‚ö†Ô∏è No audio input detected - check microphone permissions and levels');\r\n                }\r\n            }\r\n        }, 20);\r\n    }\r\n\r\n    startVolumeAnalysis() {\r\n        if (!this.analyser || !this.dataArray) {\r\n            console.warn('‚ö†Ô∏è Cannot start volume analysis - analyser not ready');\r\n            return;\r\n        }\r\n        \r\n        console.log('üìà Starting volume analysis...');\r\n        \r\n        const analyze = () => {\r\n            if (!this.initialized || !this.analyser) return;\r\n            \r\n            // Get frequency data\r\n            this.analyser.getByteFrequencyData(this.dataArray);\r\n            \r\n            // Calculate volume level (0-100) with better sensitivity\r\n            const average = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;\r\n            let volume = Math.min(100, (average / 80) * 100); // More sensitive scaling\r\n            \r\n            // Also calculate RMS for better voice detection\r\n            const timeDataArray = new Uint8Array(this.analyser.fftSize);\r\n            this.analyser.getByteTimeDomainData(timeDataArray);\r\n            \r\n            let rmsSum = 0;\r\n            for (let i = 0; i < timeDataArray.length; i++) {\r\n                const sample = (timeDataArray[i] - 128) / 128;\r\n                rmsSum += sample * sample;\r\n            }\r\n            const rms = Math.sqrt(rmsSum / timeDataArray.length);\r\n            const rmsVolume = Math.min(100, rms * 200); // Scale RMS to 0-100\r\n            \r\n            // Use the higher of the two methods\r\n            volume = Math.max(volume, rmsVolume);\r\n            \r\n            // Notify all callbacks\r\n            this.volumeCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(volume, this.dataArray);\r\n                } catch (error) {\r\n                    console.error('üí• Error in volume callback:', error);\r\n                }\r\n            });\r\n            \r\n            requestAnimationFrame(analyze);\r\n        };\r\n        \r\n        analyze();\r\n    }\r\n\r\n    addVolumeCallback(callback) {\r\n        this.volumeCallbacks.push(callback);\r\n        console.log(`üìä Added volume callback, total: ${this.volumeCallbacks.length}`);\r\n    }\r\n\r\n    removeVolumeCallback(callback) {\r\n        this.volumeCallbacks = this.volumeCallbacks.filter(cb => cb !== callback);\r\n        console.log(`üìä Removed volume callback, remaining: ${this.volumeCallbacks.length}`);\r\n    }\r\n\r\n    isInitialized() {\r\n        const hasStream = this.localStream && this.localStream.getAudioTracks().length > 0;\r\n        const hasActiveTrack = hasStream && this.localStream.getAudioTracks().some(track => \r\n            track.readyState === 'live' && track.enabled\r\n        );\r\n        \r\n        console.log('üîç Audio status check:', {\r\n            initialized: this.initialized,\r\n            hasStream,\r\n            hasActiveTrack,\r\n            contextState: this.audioContext?.state\r\n        });\r\n        \r\n        return this.initialized && hasActiveTrack;\r\n    }\r\n\r\n    async changeInputDevice(deviceId) {\r\n        if (!deviceId) {\r\n            console.warn('‚ö†Ô∏è No device ID provided for input change');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            console.log('üîÑ Changing input device to:', deviceId);\r\n            \r\n            // Stop current stream\r\n            if (this.localStream) {\r\n                this.localStream.getTracks().forEach(track => {\r\n                    console.log('üõë Stopping track for device change:', track.label);\r\n                    track.stop();\r\n                });\r\n            }\r\n\r\n            // Get new stream with specific device\r\n            const constraints = {\r\n                audio: {\r\n                    deviceId: { exact: deviceId },\r\n                    echoCancellation: true,\r\n                    noiseSuppression: true,\r\n                    autoGainControl: true,\r\n                    sampleRate: { ideal: 48000 },\r\n                    channelCount: { ideal: 1 }\r\n                }\r\n            };\r\n\r\n            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n            console.log('‚úÖ New audio stream created with device:', deviceId);\r\n\r\n            // Update audio context\r\n            if (this.micSource) {\r\n                this.micSource.disconnect();\r\n            }\r\n            this.micSource = this.audioContext.createMediaStreamSource(this.localStream);\r\n            this.micSource.connect(this.gainNode);\r\n\r\n            // Replace tracks in all peer connections\r\n            const audioTrack = this.localStream.getAudioTracks()[0];\r\n            console.log(`üîÑ Updating ${this.peerConnections.size} peer connections with new track`);\r\n            \r\n            this.peerConnections.forEach((pc, userId) => {\r\n                const senders = pc.getSenders();\r\n                const audioSender = senders.find(sender => \r\n                    sender.track && sender.track.kind === 'audio'\r\n                );\r\n                if (audioSender) {\r\n                    audioSender.replaceTrack(audioTrack);\r\n                    console.log('‚úÖ Replaced audio track for peer:', userId);\r\n                }\r\n            });\r\n\r\n            console.log('üéâ Audio input device changed successfully');\r\n        } catch (error) {\r\n            console.error('‚ùå Error changing audio input device:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async changeOutputDevice(deviceId) {\r\n        try {\r\n            console.log('üîä Changing output device to:', deviceId);\r\n            \r\n            // Update all existing audio elements\r\n            const audioElements = document.querySelectorAll('audio');\r\n            console.log(`üîÑ Updating ${audioElements.length} audio elements`);\r\n            \r\n            for (const audio of audioElements) {\r\n                if (typeof audio.setSinkId === 'function') {\r\n                    await audio.setSinkId(deviceId);\r\n                    console.log('‚úÖ Updated audio element output device');\r\n                }\r\n            }\r\n            \r\n            // Store for future audio elements\r\n            this.currentOutputDevice = deviceId;\r\n            \r\n            console.log('üéâ Audio output device changed successfully');\r\n        } catch (error) {\r\n            console.error('‚ùå Error changing audio output device:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async testOutput() {\r\n        try {\r\n            console.log('üîä Testing audio output...');\r\n            \r\n            // Create a simple test tone instead of loading a file\r\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n            const oscillator = audioContext.createOscillator();\r\n            const gainNode = audioContext.createGain();\r\n            \r\n            oscillator.connect(gainNode);\r\n            gainNode.connect(audioContext.destination);\r\n            \r\n            oscillator.frequency.value = 440; // A4 note\r\n            oscillator.type = 'sine';\r\n            \r\n            gainNode.gain.setValueAtTime(0, audioContext.currentTime);\r\n            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\r\n            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);\r\n            \r\n            oscillator.start(audioContext.currentTime);\r\n            oscillator.stop(audioContext.currentTime + 0.5);\r\n            \r\n            console.log('üéµ Test tone played successfully');\r\n            \r\n            // Clean up\r\n            setTimeout(() => {\r\n                audioContext.close();\r\n            }, 1000);\r\n            \r\n        } catch (error) {\r\n            console.error('‚ùå Error playing test audio:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    startPersistentVisualizer() {\r\n        if (this.persistentVisualizerActive) return;\r\n\r\n        console.log('üìä Starting persistent visualizer...');\r\n        this.persistentVisualizerActive = true;\r\n        \r\n        const micLevelFill = document.getElementById('persistentMicLevelFill');\r\n        const volumeLevel = document.getElementById('persistentVolumeLevel');\r\n        const micStatusText = document.getElementById('micStatusText');\r\n        \r\n        if (micStatusText) {\r\n            micStatusText.textContent = 'Monitoring microphone...';\r\n        }\r\n        \r\n        this.persistentVisualizerCallback = (volume, frequencyData) => {\r\n            if (micLevelFill && volumeLevel) {\r\n                micLevelFill.style.width = `${volume}%`;\r\n                volumeLevel.textContent = `${Math.round(volume)}%`;\r\n                \r\n                // Change color based on volume\r\n                if (volume > 50) {\r\n                    micLevelFill.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--danger) 100%)';\r\n                } else if (volume > 20) {\r\n                    micLevelFill.style.background = 'linear-gradient(90deg, var(--success) 0%, var(--warning) 100%)';\r\n                } else {\r\n                    micLevelFill.style.background = 'var(--success)';\r\n                }\r\n            }\r\n        };\r\n        \r\n        this.addVolumeCallback(this.persistentVisualizerCallback);\r\n    }\r\n\r\n    stopPersistentVisualizer() {\r\n        if (this.persistentVisualizerCallback) {\r\n            this.removeVolumeCallback(this.persistentVisualizerCallback);\r\n            this.persistentVisualizerCallback = null;\r\n        }\r\n        this.persistentVisualizerActive = false;\r\n        \r\n        console.log('üìä Stopped persistent visualizer');\r\n        \r\n        const micLevelFill = document.getElementById('persistentMicLevelFill');\r\n        const volumeLevel = document.getElementById('persistentVolumeLevel');\r\n        const micStatusText = document.getElementById('micStatusText');\r\n        \r\n        if (micLevelFill && volumeLevel) {\r\n            micLevelFill.style.width = '0%';\r\n            volumeLevel.textContent = '0%';\r\n        }\r\n        if (micStatusText) {\r\n            micStatusText.textContent = 'Click \"Test Microphone\" to start monitoring';\r\n        }\r\n    }\r\n\r\n    async testMicrophone() {\r\n        try {\r\n            console.log('üß™ Testing microphone...');\r\n            \r\n            if (!this.initialized) {\r\n                console.log('üîÑ Initializing audio for microphone test...');\r\n                await this.initialize();\r\n            }\r\n            \r\n            // Create test visualizer elements if they don't exist\r\n            this.createMicTestVisualizer();\r\n            \r\n            const visualizerContainer = document.getElementById('micTestVisualizer');\r\n            const volumeText = document.getElementById('volumeLevel');\r\n            const levelFill = document.getElementById('micLevelFill');\r\n            \r\n            if (visualizerContainer) {\r\n                visualizerContainer.style.display = 'block';\r\n            }\r\n            \r\n            let maxVolumeDetected = 0;\r\n            \r\n            let testCallback = (volume, frequencyData) => {\r\n                maxVolumeDetected = Math.max(maxVolumeDetected, volume);\r\n                \r\n                if (levelFill && volumeText) {\r\n                    levelFill.style.width = `${volume}%`;\r\n                    volumeText.textContent = `${Math.round(volume)}%`;\r\n                    \r\n                    // Dynamic color based on volume\r\n                    if (volume > 50) {\r\n                        levelFill.style.background = 'linear-gradient(90deg, var(--warning) 0%, var(--danger) 100%)';\r\n                    } else if (volume > 20) {\r\n                        levelFill.style.background = 'linear-gradient(90deg, var(--success) 0%, var(--warning) 100%)';\r\n                    } else {\r\n                        levelFill.style.background = 'var(--success)';\r\n                    }\r\n                }\r\n            };\r\n            \r\n            this.addVolumeCallback(testCallback);\r\n            \r\n            setTimeout(() => {\r\n                this.removeVolumeCallback(testCallback);\r\n                if (visualizerContainer) {\r\n                    visualizerContainer.style.display = 'none';\r\n                }\r\n                \r\n                // Report results\r\n                console.log('üìä Microphone test completed. Max volume detected:', maxVolumeDetected);\r\n                if (maxVolumeDetected > 5) {\r\n                    console.log('‚úÖ Microphone is working properly!');\r\n                } else {\r\n                    console.warn('‚ö†Ô∏è Low or no microphone input detected');\r\n                }\r\n            }, 10000);\r\n            \r\n        } catch (error) {\r\n            console.error('‚ùå Error testing microphone:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    createMicTestVisualizer() {\r\n        if (document.getElementById('micTestVisualizer')) return;\r\n        \r\n        const testMicrophoneBtn = document.getElementById('testMicrophone');\r\n        if (!testMicrophoneBtn) return;\r\n        \r\n        const testMicContainer = testMicrophoneBtn.parentElement;\r\n        \r\n        const visualizerContainer = document.createElement('div');\r\n        visualizerContainer.id = 'micTestVisualizer';\r\n        visualizerContainer.style.cssText = `\r\n            margin-top: 1rem;\r\n            padding: 1rem;\r\n            background: var(--dark-bg);\r\n            border-radius: 8px;\r\n            border: 1px solid var(--border);\r\n            display: none;\r\n        `;\r\n        \r\n        const visualizerTitle = document.createElement('h4');\r\n        visualizerTitle.textContent = 'Microphone Test (10 seconds) - Speak now!';\r\n        visualizerTitle.style.cssText = `\r\n            color: var(--text-secondary);\r\n            margin-bottom: 0.5rem;\r\n            font-size: 0.9rem;\r\n        `;\r\n        \r\n        const visualizerBar = document.createElement('div');\r\n        visualizerBar.id = 'micLevelBar';\r\n        visualizerBar.style.cssText = `\r\n            width: 100%;\r\n            height: 24px;\r\n            background: var(--border);\r\n            border-radius: 12px;\r\n            overflow: hidden;\r\n            position: relative;\r\n        `;\r\n        \r\n        const visualizerFill = document.createElement('div');\r\n        visualizerFill.id = 'micLevelFill';\r\n        visualizerFill.style.cssText = `\r\n            height: 100%;\r\n            width: 0%;\r\n            background: linear-gradient(90deg, var(--success) 0%, var(--warning) 70%, var(--danger) 100%);\r\n            transition: width 0.1s ease;\r\n            border-radius: 12px;\r\n        `;\r\n        \r\n        const volumeText = document.createElement('span');\r\n        volumeText.id = 'volumeLevel';\r\n        volumeText.style.cssText = `\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            transform: translate(-50%, -50%);\r\n            font-size: 0.85rem;\r\n            font-weight: bold;\r\n            color: var(--text-primary);\r\n            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);\r\n        `;\r\n        volumeText.textContent = '0%';\r\n        \r\n        visualizerBar.appendChild(visualizerFill);\r\n        visualizerBar.appendChild(volumeText);\r\n        visualizerContainer.appendChild(visualizerTitle);\r\n        visualizerContainer.appendChild(visualizerBar);\r\n        \r\n        testMicContainer.appendChild(visualizerContainer);\r\n    }\r\n\r\n    async connectToUser(userId, username, userColor) {\r\n        if (this.peerConnections.has(userId)) {\r\n            console.log('üîó Already connected to user:', userId);\r\n            return;\r\n        }\r\n\r\n        console.log('ü§ù Connecting to user:', userId, username);\r\n        \r\n        const peerConnection = new RTCPeerConnection({ iceServers: this.iceServers });\r\n        this.peerConnections.set(userId, peerConnection);\r\n\r\n        // Add local stream\r\n        if (this.localStream && this.isInitialized()) {\r\n            const audioTracks = this.localStream.getAudioTracks();\r\n            console.log(`üéµ Adding ${audioTracks.length} audio track(s) for answer`);\r\n            \r\n            audioTracks.forEach(track => {\r\n                console.log('‚ûï Adding track for answer:', {\r\n                    label: track.label,\r\n                    enabled: track.enabled,\r\n                    readyState: track.readyState\r\n                });\r\n                peerConnection.addTrack(track, this.localStream);\r\n            });\r\n        }\r\n\r\n        // Handle incoming stream\r\n        peerConnection.ontrack = (event) => {\r\n            console.log('üì• Received remote stream from:', userId);\r\n            const remoteStream = event.streams[0];\r\n            \r\n            // Create audio element\r\n            const audioElement = document.createElement('audio');\r\n            audioElement.autoplay = true;\r\n            audioElement.srcObject = remoteStream;\r\n            audioElement.volume = 1;\r\n            audioElement.style.display = 'none';\r\n            \r\n            // Set output device if one is selected\r\n            if (this.currentOutputDevice && typeof audioElement.setSinkId === 'function') {\r\n                audioElement.setSinkId(this.currentOutputDevice).catch(console.error);\r\n            }\r\n            \r\n            // Add to participant\r\n            const participant = document.getElementById(`voice-participant-${userId}-${window.proximityApp?.currentVoiceChannel?.replace('-voice', '')}`);\r\n            if (participant) {\r\n                participant.appendChild(audioElement);\r\n                console.log('üîä Audio element attached to participant');\r\n            }\r\n            \r\n            // Notify proximity map\r\n            if (window.proximityApp && window.proximityApp.proximityMap) {\r\n                window.proximityApp.proximityMap.setUserAudioElement(userId, audioElement);\r\n            }\r\n        };\r\n\r\n        // Handle ICE candidates\r\n        peerConnection.onicecandidate = (event) => {\r\n            if (event.candidate && window.proximityApp) {\r\n                window.proximityApp.connectionManager.emit('ice-candidate', {\r\n                    target: userId,\r\n                    candidate: event.candidate\r\n                });\r\n            }\r\n        };\r\n\r\n        // Connection state monitoring\r\n        peerConnection.onconnectionstatechange = () => {\r\n            console.log(`üîó Connection state with ${userId}:`, peerConnection.connectionState);\r\n        };\r\n\r\n        try {\r\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n            const answer = await peerConnection.createAnswer();\r\n            await peerConnection.setLocalDescription(answer);\r\n            \r\n            console.log('üì§ Created answer for:', userId);\r\n            \r\n            if (window.proximityApp) {\r\n                window.proximityApp.connectionManager.emit('answer', {\r\n                    target: userId,\r\n                    answer: answer\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('‚ùå Error handling offer from:', userId, error);\r\n            this.peerConnections.delete(userId);\r\n        }\r\n    }\r\n\r\n    async handleOffer(offer, from) {\r\n        console.log('üì• Handling offer from:', from);\r\n        \r\n        if (this.peerConnections.has(from)) {\r\n            console.log('üîó Connection already exists for user:', from);\r\n            return;\r\n        }\r\n\r\n        const peerConnection = new RTCPeerConnection({ iceServers: this.iceServers });\r\n        this.peerConnections.set(from, peerConnection);\r\n\r\n        // Add local stream\r\n        if (this.localStream) {\r\n            const audioTracks = this.localStream.getAudioTracks();\r\n            console.log('üéµ Adding audio tracks to answer peer connection:', audioTracks.length);\r\n            \r\n            audioTracks.forEach(track => {\r\n                console.log('‚ûï Adding track for answer:', track.label, 'enabled:', track.enabled);\r\n                peerConnection.addTrack(track, this.localStream);\r\n            });\r\n        }\r\n\r\n        // Handle incoming stream\r\n        peerConnection.ontrack = (event) => {\r\n            console.log('üì• Received remote stream from:', from);\r\n            const remoteStream = event.streams[0];\r\n            \r\n            // Create audio element\r\n            const audioElement = document.createElement('audio');\r\n            audioElement.autoplay = true;\r\n            audioElement.srcObject = remoteStream;\r\n            audioElement.volume = 1;\r\n            audioElement.style.display = 'none';\r\n            \r\n            // Set output device if one is selected\r\n            if (this.currentOutputDevice && typeof audioElement.setSinkId === 'function') {\r\n                audioElement.setSinkId(this.currentOutputDevice).catch(console.error);\r\n            }\r\n            \r\n            // Add to participant\r\n            const participant = document.getElementById(`voice-participant-${from}-${window.proximityApp?.currentVoiceChannel?.replace('-voice', '')}`);\r\n            if (participant) {\r\n                participant.appendChild(audioElement);\r\n            }\r\n            \r\n            // Notify proximity map\r\n            if (window.proximityApp && window.proximityApp.proximityMap) {\r\n                window.proximityApp.proximityMap.setUserAudioElement(from, audioElement);\r\n            }\r\n        };\r\n\r\n        // Handle ICE candidates\r\n        peerConnection.onicecandidate = (event) => {\r\n            if (event.candidate && window.proximityApp) {\r\n                window.proximityApp.connectionManager.emit('ice-candidate', {\r\n                    target: from,\r\n                    candidate: event.candidate\r\n                });\r\n            }\r\n        };\r\n\r\n        try {\r\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n            const answer = await peerConnection.createAnswer();\r\n            await peerConnection.setLocalDescription(answer);\r\n            \r\n            console.log('üì§ Created answer for:', from);\r\n            \r\n            if (window.proximityApp) {\r\n                window.proximityApp.connectionManager.emit('answer', {\r\n                    target: from,\r\n                    answer: answer\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('‚ùå Error handling offer from:', from, error);\r\n            this.peerConnections.delete(from);\r\n        }\r\n    }\r\n\r\n    async handleAnswer(answer, from) {\r\n        console.log('üì• Handling answer from:', from);\r\n        \r\n        const peerConnection = this.peerConnections.get(from);\r\n        if (!peerConnection) {\r\n            console.warn('‚ö†Ô∏è No peer connection found for:', from);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            if (peerConnection.signalingState === 'have-local-offer') {\r\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\r\n                console.log('‚úÖ Set remote description for answer from:', from);\r\n            } else {\r\n                console.warn(`‚ö†Ô∏è Cannot set remote answer in state: ${peerConnection.signalingState}`);\r\n            }\r\n        } catch (error) {\r\n            console.error('‚ùå Error handling answer from:', from, error);\r\n            this.disconnectFromUser(from);\r\n        }\r\n    }\r\n\r\n    async handleIceCandidate(candidate, from) {\r\n        const peerConnection = this.peerConnections.get(from);\r\n        if (!peerConnection) {\r\n            console.warn('‚ö†Ô∏è No peer connection found for ICE candidate from:', from);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            if (peerConnection.remoteDescription) {\r\n                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\r\n                console.log('‚úÖ Added ICE candidate from:', from);\r\n            } else {\r\n                // Queue candidates if remote description not set yet\r\n                if (!peerConnection.queuedCandidates) {\r\n                    peerConnection.queuedCandidates = [];\r\n                }\r\n                peerConnection.queuedCandidates.push(candidate);\r\n                console.log('üì¶ Queued ICE candidate from:', from);\r\n            }\r\n        } catch (error) {\r\n            console.error('‚ùå Error handling ICE candidate from:', from, error);\r\n        }\r\n    }\r\n\r\n    disconnectFromUser(userId) {\r\n        const peerConnection = this.peerConnections.get(userId);\r\n        if (peerConnection) {\r\n            peerConnection.close();\r\n            this.peerConnections.delete(userId);\r\n            console.log('üîå Disconnected from user:', userId);\r\n        }\r\n    }\r\n\r\n    disconnectAll() {\r\n        console.log(`üîå Disconnecting from all ${this.peerConnections.size} users...`);\r\n        this.peerConnections.forEach((pc, userId) => {\r\n            pc.close();\r\n            console.log('üîå Closed connection to:', userId);\r\n        });\r\n        this.peerConnections.clear();\r\n    }\r\n\r\n    toggleMute() {\r\n        if (!this.localStream) {\r\n            console.warn('‚ö†Ô∏è No local stream to mute/unmute');\r\n            return;\r\n        }\r\n\r\n        this.isMuted = !this.isMuted;\r\n        \r\n        this.localStream.getAudioTracks().forEach(track => {\r\n            track.enabled = !this.isMuted;\r\n            console.log(`üé§ Audio track ${track.label} enabled: ${track.enabled}`);\r\n        });\r\n\r\n        // Update UI\r\n        if (window.proximityApp && window.proximityApp.uiManager) {\r\n            window.proximityApp.uiManager.updateMuteStatus(this.isMuted);\r\n        }\r\n\r\n        // Notify server\r\n        if (window.proximityApp) {\r\n            window.proximityApp.updateMicStatus(this.isMuted);\r\n        }\r\n\r\n        console.log(`üé§ Microphone ${this.isMuted ? 'muted' : 'unmuted'}`);\r\n    }\r\n\r\n    setGain(value) {\r\n        // value: 0-100, map to 0-2\r\n        const gainValue = Math.max(0, Math.min(2, value / 50));\r\n        if (this.gainNode) {\r\n            this.gainNode.gain.setValueAtTime(gainValue, this.audioContext.currentTime);\r\n            console.log(`üîä Audio gain set to: ${gainValue} (from ${value}%)`);\r\n        }\r\n    }\r\n\r\n    getLocalStream() {\r\n        return this.localStream;\r\n    }\r\n\r\n    cleanup() {\r\n        console.log('üßπ Cleaning up audio manager...');\r\n        \r\n        this.disconnectAll();\r\n        \r\n        if (this.localStream) {\r\n            this.localStream.getTracks().forEach(track => {\r\n                console.log('üõë Stopping track during cleanup:', track.label);\r\n                track.stop();\r\n            });\r\n            this.localStream = null;\r\n        }\r\n\r\n        if (this.audioContext && this.audioContext.state !== 'closed') {\r\n            this.audioContext.close();\r\n            console.log('üîå Closed audio context');\r\n        }\r\n\r\n        this.volumeCallbacks = [];\r\n        this.initialized = false;\r\n        this.initializationAttempts = 0;\r\n        \r\n        console.log('‚úÖ Audio manager cleanup complete');\r\n    }\r\n}","// src/renderer/js/chat/ChatManager.js - Updated with channel support\r\nexport class ChatManager {\r\n    constructor() {\r\n        this.currentChannel = 'diamond';\r\n    }\r\n\r\n    sendMessage(message, channel = null) {\r\n        if (!message.trim()) return;\r\n\r\n        if (!window.proximityApp || !window.proximityApp.connectionManager.socket) {\r\n            console.error('Not connected to server');\r\n            return;\r\n        }\r\n\r\n        if (!window.proximityApp.isInHub) {\r\n            console.error('Not in hub');\r\n            return;\r\n        }\r\n\r\n        const username = window.proximityApp.settingsManager.get('username') || 'Anonymous';\r\n        const targetChannel = channel || this.currentChannel;\r\n        \r\n        console.log('Sending chat message:', message, 'to channel:', targetChannel);\r\n\r\n        window.proximityApp.connectionManager.emit('send-chat-message', {\r\n            roomId: 'hub',\r\n            message: message,\r\n            username: username,\r\n            channel: targetChannel\r\n        });\r\n    }\r\n\r\n    addMessage(data) {\r\n        if (!window.proximityApp || !window.proximityApp.uiManager) return;\r\n\r\n        console.log('Adding chat message:', data);\r\n        \r\n        // Pass channel info to UI manager\r\n        window.proximityApp.uiManager.addChatMessage(\r\n            data.username,\r\n            data.message,\r\n            data.timestamp || Date.now(),\r\n            data.channel\r\n        );\r\n    }\r\n\r\n    setCurrentChannel(channel) {\r\n        this.currentChannel = channel;\r\n    }\r\n\r\n    getCurrentChannel() {\r\n        return this.currentChannel;\r\n    }\r\n\r\n    clearMessages() {\r\n        const chatMessages = document.getElementById('chatMessages');\r\n        if (chatMessages) {\r\n            chatMessages.innerHTML = '';\r\n        }\r\n    }\r\n}","// src/renderer/js/core/ConnectionManager.js\r\nexport class ConnectionManager {\r\n    constructor(serverUrl) {\r\n        this.serverUrl = serverUrl;\r\n        this.socket = null;\r\n        this.isConnected = false;\r\n        this.reconnectAttempts = 0;\r\n        this.maxReconnectAttempts = 5;\r\n    }\r\n\r\n    async connect() {\r\n        return new Promise((resolve, reject) => {\r\n            if (typeof io === 'undefined') {\r\n                reject(new Error('Socket.IO not loaded'));\r\n                return;\r\n            }\r\n\r\n            console.log('Connecting to server:', this.serverUrl);\r\n            \r\n            this.socket = io(this.serverUrl, {\r\n                reconnectionAttempts: this.maxReconnectAttempts,\r\n                timeout: 10000,\r\n                transports: ['websocket', 'polling']\r\n            });\r\n\r\n            this.socket.on('connect', () => {\r\n                console.log('Connected to server');\r\n                this.isConnected = true;\r\n                this.reconnectAttempts = 0;\r\n                resolve();\r\n            });\r\n\r\n            this.socket.on('disconnect', () => {\r\n                console.log('Disconnected from server');\r\n                this.isConnected = false;\r\n            });\r\n\r\n            this.socket.on('connect_error', (error) => {\r\n                console.error('Connection error:', error);\r\n                this.isConnected = false;\r\n                this.reconnectAttempts++;\r\n                \r\n                if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n                    reject(new Error('Failed to connect to server after multiple attempts'));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    disconnect() {\r\n        if (this.socket) {\r\n            this.socket.disconnect();\r\n            this.socket = null;\r\n            this.isConnected = false;\r\n        }\r\n    }\r\n\r\n    emit(event, data) {\r\n        if (this.socket && this.isConnected) {\r\n            this.socket.emit(event, data);\r\n        } else {\r\n            console.warn('Attempted to emit event while disconnected:', event);\r\n        }\r\n    }\r\n\r\n    on(event, callback) {\r\n        if (this.socket) {\r\n            this.socket.on(event, callback);\r\n        }\r\n    }\r\n}","// src/renderer/js/proximity/ProximityMap.js - Complete fixed version\r\nexport class ProximityMap {\r\n    constructor(canvas, app) {\r\n        this.canvas = canvas;\r\n        this.ctx = canvas.getContext('2d');\r\n        this.app = app;\r\n        this.users = new Map(); // userId -> {x, y, username, isSelf, audioElement}\r\n        this.myUserId = null;\r\n        this.proximityRange = 100;\r\n        this.isDragging = false;\r\n        this.dragOffset = { x: 0, y: 0 };\r\n        this.testBotId = null;\r\n        this.testBotMovementInterval = null;\r\n        \r\n        // Audio constants for proximity calculation\r\n        this.EDGE_START = 0.75; // When edge effects begin\r\n        this.OUTER_RANGE = 1.3; // Allow audio to continue beyond visible range\r\n        \r\n        this.setupEventListeners();\r\n        this.startRenderLoop();\r\n        this.resizeCanvas();\r\n        \r\n        window.addEventListener('resize', () => this.resizeCanvas());\r\n    }\r\n\r\n    resizeCanvas() {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        this.canvas.width = rect.width;\r\n        this.canvas.height = rect.height;\r\n    }\r\n\r\n    setupEventListeners() {\r\n        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\r\n        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\r\n        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());\r\n        this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());\r\n        \r\n        // Touch events for mobile\r\n        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));\r\n        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));\r\n        this.canvas.addEventListener('touchend', () => this.handleMouseUp());\r\n    }\r\n\r\n    handleMouseDown(e) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n        \r\n        if (this.myUserId && this.users.has(this.myUserId)) {\r\n            const myUser = this.users.get(this.myUserId);\r\n            const distance = Math.sqrt((x - myUser.x) ** 2 + (y - myUser.y) ** 2);\r\n            \r\n            if (distance <= 20) { // User circle radius is 20px\r\n                this.isDragging = true;\r\n                this.dragOffset = { x: x - myUser.x, y: y - myUser.y };\r\n                this.canvas.style.cursor = 'grabbing';\r\n            }\r\n        }\r\n    }\r\n\r\n    handleMouseMove(e) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n        \r\n        if (this.isDragging && this.myUserId) {\r\n            const newX = Math.max(20, Math.min(this.canvas.width - 20, x - this.dragOffset.x));\r\n            const newY = Math.max(20, Math.min(this.canvas.height - 20, y - this.dragOffset.y));\r\n            \r\n            this.updateUserPosition(this.myUserId, newX, newY);\r\n            this.updateAudioProximity();\r\n            \r\n            // Emit position update to other users\r\n            if (this.app && this.app.sendPositionUpdate) {\r\n                this.app.sendPositionUpdate(newX, newY);\r\n            }\r\n        } else {\r\n            // Update cursor based on hover\r\n            let isHovering = false;\r\n            if (this.myUserId && this.users.has(this.myUserId)) {\r\n                const myUser = this.users.get(this.myUserId);\r\n                const distance = Math.sqrt((x - myUser.x) ** 2 + (y - myUser.y) ** 2);\r\n                isHovering = distance <= 20;\r\n            }\r\n            this.canvas.style.cursor = isHovering ? 'grab' : 'crosshair';\r\n        }\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.isDragging = false;\r\n        this.canvas.style.cursor = 'crosshair';\r\n    }\r\n\r\n    handleTouchStart(e) {\r\n        e.preventDefault();\r\n        const touch = e.touches[0];\r\n        const mouseEvent = new MouseEvent('mousedown', {\r\n            clientX: touch.clientX,\r\n            clientY: touch.clientY\r\n        });\r\n        this.handleMouseDown(mouseEvent);\r\n    }\r\n\r\n    handleTouchMove(e) {\r\n        e.preventDefault();\r\n        const touch = e.touches[0];\r\n        const mouseEvent = new MouseEvent('mousemove', {\r\n            clientX: touch.clientX,\r\n            clientY: touch.clientY\r\n        });\r\n        this.handleMouseMove(mouseEvent);\r\n    }\r\n\r\n    addUser(userId, username, isSelf = false, audioElement = null) {\r\n        // Center spawn position with slight randomization\r\n        const x = this.canvas.width / 2 + (Math.random() - 0.5) * 100;\r\n        const y = this.canvas.height / 2 + (Math.random() - 0.5) * 100;\r\n        \r\n        let userColor = 'blue';\r\n        if (isSelf && this.app && this.app.settingsManager) {\r\n            userColor = this.app.settingsManager.get('userColor') || 'purple';\r\n        }\r\n        \r\n        this.users.set(userId, {\r\n            x,\r\n            y,\r\n            username: username || `User ${userId.slice(0, 4)}`,\r\n            isSelf,\r\n            audioElement,\r\n            lastUpdate: Date.now(),\r\n            color: userColor\r\n        });\r\n\r\n        if (isSelf) {\r\n            this.myUserId = userId;\r\n        }\r\n\r\n        this.updateAudioProximity();\r\n    }\r\n\r\n    removeUser(userId) {\r\n        this.users.delete(userId);\r\n        if (this.myUserId === userId) {\r\n            this.myUserId = null;\r\n        }\r\n        this.updateAudioProximity();\r\n    }\r\n\r\n    clearUsers() {\r\n        this.users.clear();\r\n        this.myUserId = null;\r\n    }\r\n\r\n    updateUserPosition(userId, x, y) {\r\n        if (this.users.has(userId)) {\r\n            const user = this.users.get(userId);\r\n            user.x = x;\r\n            user.y = y;\r\n            user.lastUpdate = Date.now();\r\n        }\r\n    }\r\n\r\n    updateUserColor(userId, color) {\r\n        if (this.users.has(userId)) {\r\n            this.users.get(userId).color = color;\r\n        }\r\n    }\r\n\r\n    setUserAudioElement(userId, audioElement) {\r\n        if (this.users.has(userId)) {\r\n            this.users.get(userId).audioElement = audioElement;\r\n            this.updateAudioProximity();\r\n        }\r\n    }\r\n\r\n    centerMyPosition() {\r\n        if (!this.myUserId || !this.users.has(this.myUserId)) return;\r\n\r\n        const centerX = this.canvas.width / 2;\r\n        const centerY = this.canvas.height / 2;\r\n        \r\n        this.updateUserPosition(this.myUserId, centerX, centerY);\r\n        this.updateAudioProximity();\r\n        \r\n        // Emit position update\r\n        if (this.app && this.app.sendPositionUpdate) {\r\n            this.app.sendPositionUpdate(centerX, centerY);\r\n        }\r\n    }\r\n\r\n    setProximityRange(range) {\r\n        console.log('Setting proximity range to:', range);\r\n        this.proximityRange = range;\r\n        this.updateAudioProximity();\r\n    }\r\n\r\n    updateAudioProximity() {\r\n        if (!this.myUserId || !this.users.has(this.myUserId)) return;\r\n\r\n        const myUser = this.users.get(this.myUserId);\r\n        \r\n        this.users.forEach((user, userId) => {\r\n            if (userId === this.myUserId || !user.audioElement) return;\r\n\r\n            const distance = Math.sqrt(\r\n                (myUser.x - user.x) ** 2 + (myUser.y - user.y) ** 2\r\n            );\r\n\r\n            // Calculate volume based on proximity (0 to 1)\r\n            let volume = 0;\r\n            \r\n            const normalizedDistance = distance / this.proximityRange;\r\n            \r\n            if (normalizedDistance <= this.OUTER_RANGE) {\r\n                if (normalizedDistance > this.EDGE_START && normalizedDistance <= 1.0) {\r\n                    // Extra feathering at the edge\r\n                    const edgeFactor = (1 - normalizedDistance) / (1 - this.EDGE_START);\r\n                    volume = Math.pow(edgeFactor, 2) * 0.3;\r\n                } else if (normalizedDistance > 1.0 && normalizedDistance <= this.OUTER_RANGE) {\r\n                    // Extended fadeout beyond visible range\r\n                    const fadeoutFactor = (this.OUTER_RANGE - normalizedDistance) / (this.OUTER_RANGE - 1.0);\r\n                    volume = Math.pow(fadeoutFactor, 3) * 0.1;\r\n                } else {\r\n                    // Normal falloff for closer distances\r\n                    volume = Math.max(0, 1 - normalizedDistance);\r\n                    volume = Math.pow(volume, 0.4);\r\n                }\r\n            }\r\n\r\n            // Apply volume with smoothing\r\n            if (user.audioElement) {\r\n                const currentVolume = user.audioElement.volume;\r\n                const smoothedVolume = currentVolume * 0.8 + volume * 0.2;\r\n                user.audioElement.volume = smoothedVolume;\r\n            }\r\n        });\r\n    }\r\n\r\n    startRenderLoop() {\r\n        const render = () => {\r\n            this.render();\r\n            requestAnimationFrame(render);\r\n        };\r\n        render();\r\n    }\r\n\r\n    render() {\r\n        // Clear canvas\r\n        this.ctx.fillStyle = '#0f0f23';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Draw grid\r\n        this.drawGrid();\r\n\r\n        // Draw proximity ranges and users\r\n        this.users.forEach((user, userId) => {\r\n            if (userId === this.myUserId) {\r\n                this.drawProximityRange(user.x, user.y, user.color);\r\n            }\r\n        });\r\n\r\n        this.users.forEach((user, userId) => {\r\n            this.drawUser(user, userId === this.myUserId);\r\n        });\r\n\r\n        // Draw connection lines\r\n        if (this.myUserId && this.users.has(this.myUserId)) {\r\n            this.drawConnectionLines();\r\n        }\r\n    }\r\n\r\n    drawGrid() {\r\n        this.ctx.strokeStyle = 'rgba(107, 70, 193, 0.1)';\r\n        this.ctx.lineWidth = 1;\r\n        \r\n        const gridSize = 50;\r\n        \r\n        for (let x = 0; x <= this.canvas.width; x += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(x, 0);\r\n            this.ctx.lineTo(x, this.canvas.height);\r\n            this.ctx.stroke();\r\n        }\r\n        \r\n        for (let y = 0; y <= this.canvas.height; y += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(0, y);\r\n            this.ctx.lineTo(this.canvas.width, y);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawProximityRange(x, y, color = 'purple') {\r\n        const colorMap = {\r\n            blue: ['rgba(59,130,246,0.3)', 'rgba(59,130,246,0.08)', 'rgba(59,130,246,0.15)'],\r\n            green: ['rgba(16,185,129,0.3)', 'rgba(16,185,129,0.08)', 'rgba(16,185,129,0.15)'],\r\n            purple: ['rgba(139,92,246,0.3)', 'rgba(139,92,246,0.08)', 'rgba(139,92,246,0.15)'],\r\n            red: ['rgba(239,68,68,0.3)', 'rgba(239,68,68,0.08)', 'rgba(239,68,68,0.15)'],\r\n            orange: ['rgba(245,158,11,0.3)', 'rgba(245,158,11,0.08)', 'rgba(245,158,11,0.15)'],\r\n            pink: ['rgba(236,72,153,0.3)', 'rgba(236,72,153,0.08)', 'rgba(236,72,153,0.15)'],\r\n            indigo: ['rgba(99,102,241,0.3)', 'rgba(99,102,241,0.08)', 'rgba(99,102,241,0.15)'],\r\n            cyan: ['rgba(6,182,212,0.3)', 'rgba(6,182,212,0.08)', 'rgba(6,182,212,0.15)']\r\n        };\r\n        \r\n        const [strokeColor, fillColor, extendedStrokeColor] = colorMap[color] || colorMap['purple'];\r\n        \r\n        // Draw extended audible range (faded)\r\n        this.ctx.strokeStyle = extendedStrokeColor;\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.setLineDash([2, 4]);\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, this.proximityRange * this.OUTER_RANGE, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n        \r\n        // Draw main proximity range\r\n        this.ctx.strokeStyle = strokeColor;\r\n        this.ctx.fillStyle = fillColor;\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.setLineDash([5, 5]);\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, this.proximityRange, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n        this.ctx.stroke();\r\n        this.ctx.setLineDash([]);\r\n    }\r\n\r\n    drawUser(user, isSelf) {\r\n        const { x, y, username, color } = user;\r\n        \r\n        const colorMap = {\r\n            blue: ['#3b82f6', '#60a5fa'],\r\n            green: ['#10b981', '#34d399'],\r\n            purple: ['#8b5cf6', '#a78bfa'],\r\n            red: ['#ef4444', '#f87171'],\r\n            orange: ['#f59e0b', '#fbbf24'],\r\n            pink: ['#ec4899', '#f472b6'],\r\n            indigo: ['#6366f1', '#818cf8'],\r\n            cyan: ['#06b6d4', '#22d3ee']\r\n        };\r\n        \r\n        const [fillColor, strokeColor] = colorMap[color] || colorMap['purple'];\r\n        \r\n        this.ctx.fillStyle = fillColor;\r\n        this.ctx.strokeStyle = strokeColor;\r\n        this.ctx.lineWidth = 3;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, 20, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n        this.ctx.stroke();\r\n        \r\n        // User initial/icon\r\n        this.ctx.fillStyle = '#ffffff';\r\n        this.ctx.font = 'bold 16px sans-serif';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.textBaseline = 'middle';\r\n        \r\n        const initial = username.charAt(0).toUpperCase();\r\n        this.ctx.fillText(initial, x, y);\r\n        \r\n        // Username label\r\n        this.ctx.fillStyle = isSelf ? strokeColor : '#cbd5e1';\r\n        this.ctx.font = '12px sans-serif';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.textBaseline = 'top';\r\n        const displayName = isSelf ? `${username} (You)` : username;\r\n        this.ctx.fillText(displayName, x, y + 30);\r\n        \r\n        // Activity indicator (pulsing effect when speaking)\r\n        if (user.isActive) {\r\n            const pulseRadius = 25 + Math.sin(Date.now() * 0.01) * 5;\r\n            const glowColor = colorMap[color] ? colorMap[color][0].replace('1)', '0.6)') : 'rgba(139,92,246,0.6)';\r\n            this.ctx.strokeStyle = glowColor;\r\n            this.ctx.lineWidth = 2;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawConnectionLines() {\r\n        if (!this.myUserId || !this.users.has(this.myUserId)) return;\r\n\r\n        const myUser = this.users.get(this.myUserId);\r\n        \r\n        this.users.forEach((user, userId) => {\r\n            if (userId === this.myUserId) return;\r\n\r\n            const distance = Math.sqrt(\r\n                (myUser.x - user.x) ** 2 + (myUser.y - user.y) ** 2\r\n            );\r\n\r\n            if (distance <= this.proximityRange) {\r\n                const opacity = Math.max(0.1, 1 - (distance / this.proximityRange));\r\n                this.ctx.strokeStyle = `rgba(16, 185, 129, ${opacity * 0.5})`;\r\n                this.ctx.lineWidth = 2;\r\n                \r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(myUser.x, myUser.y);\r\n                this.ctx.lineTo(user.x, user.y);\r\n                this.ctx.stroke();\r\n            }\r\n        });\r\n    }\r\n\r\n    // Called when user speaks to show activity\r\n    setUserActivity(userId, isActive) {\r\n        if (this.users.has(userId)) {\r\n            this.users.get(userId).isActive = isActive;\r\n        }\r\n    }\r\n\r\n    // Test bot functionality - FIXED VERSION\r\n    addTestBot() {\r\n        console.log('Adding test bot...');\r\n        this.removeTestBot();\r\n\r\n        this.testBotId = 'test-bot-' + Date.now();\r\n        \r\n        // Create audio element for test sound\r\n        const audioElement = new Audio('assets/TestNoise.mp3');\r\n        audioElement.loop = true;\r\n        audioElement.volume = 0; // Start at 0, proximity will adjust\r\n        \r\n        let x, y;\r\n        if (this.myUserId && this.users.has(this.myUserId)) {\r\n            const myUser = this.users.get(this.myUserId);\r\n            const angle = Math.random() * Math.PI * 2;\r\n            const distance = this.proximityRange * 0.9; // 90% of proximity range\r\n            \r\n            x = myUser.x + Math.cos(angle) * distance;\r\n            y = myUser.y + Math.sin(angle) * distance;\r\n            \r\n            // Ensure within canvas bounds\r\n            x = Math.max(20, Math.min(this.canvas.width - 20, x));\r\n            y = Math.max(20, Math.min(this.canvas.height - 20, y));\r\n        } else {\r\n            x = Math.random() * (this.canvas.width - 40) + 20;\r\n            y = Math.random() * (this.canvas.height - 40) + 20;\r\n        }\r\n        \r\n        this.users.set(this.testBotId, {\r\n            x, y,\r\n            username: 'Test Bot',\r\n            isSelf: false,\r\n            audioElement,\r\n            lastUpdate: Date.now(),\r\n            color: 'green',\r\n            isBot: true\r\n        });\r\n        \r\n        // Play the audio\r\n        audioElement.play().catch(error => {\r\n            console.log('Audio autoplay prevented, will work after user interaction');\r\n        });\r\n        \r\n        this.updateAudioProximity();\r\n        this.startTestBotMovement();\r\n        \r\n        console.log('Test bot added successfully');\r\n        return this.testBotId;\r\n    }\r\n    \r\n    removeTestBot() {\r\n        console.log('Removing test bot...');\r\n        \r\n        if (this.testBotMovementInterval) {\r\n            clearInterval(this.testBotMovementInterval);\r\n            this.testBotMovementInterval = null;\r\n        }\r\n        \r\n        if (this.testBotId && this.users.has(this.testBotId)) {\r\n            const bot = this.users.get(this.testBotId);\r\n            \r\n            if (bot.audioElement) {\r\n                bot.audioElement.pause();\r\n                bot.audioElement.currentTime = 0;\r\n                bot.audioElement.srcObject = null;\r\n            }\r\n            \r\n            this.users.delete(this.testBotId);\r\n            this.testBotId = null;\r\n            this.updateAudioProximity();\r\n            \r\n            console.log('Test bot removed successfully');\r\n        }\r\n    }\r\n    \r\n    startTestBotMovement() {\r\n        if (this.testBotMovementInterval) {\r\n            clearInterval(this.testBotMovementInterval);\r\n        }\r\n        \r\n        this.testBotMovementInterval = setInterval(() => {\r\n            if (this.testBotId && this.users.has(this.testBotId)) {\r\n                const bot = this.users.get(this.testBotId);\r\n                \r\n                // Random movement direction\r\n                const targetX = Math.random() * (this.canvas.width - 40) + 20;\r\n                const targetY = Math.random() * (this.canvas.height - 40) + 20;\r\n                \r\n                // Animate the movement over 3 seconds\r\n                const startX = bot.x;\r\n                const startY = bot.y;\r\n                const startTime = Date.now();\r\n                const duration = 3000;\r\n                \r\n                const animateMovement = () => {\r\n                    const elapsed = Date.now() - startTime;\r\n                    const progress = Math.min(elapsed / duration, 1);\r\n                    \r\n                    // Ease-in-out movement\r\n                    const easing = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;\r\n                    \r\n                    bot.x = startX + (targetX - startX) * easing;\r\n                    bot.y = startY + (targetY - startY) * easing;\r\n                    \r\n                    if (progress < 1) {\r\n                        requestAnimationFrame(animateMovement);\r\n                    }\r\n                    \r\n                    // Update audio proximity after each movement step\r\n                    this.updateAudioProximity();\r\n                };\r\n                \r\n                animateMovement();\r\n                \r\n                // Show speaking activity for half a second\r\n                bot.isActive = true;\r\n                setTimeout(() => {\r\n                    if (this.testBotId && this.users.has(this.testBotId)) {\r\n                        this.users.get(this.testBotId).isActive = false;\r\n                    }\r\n                }, 500);\r\n            }\r\n        }, 5000); // Move every 5 seconds\r\n    }\r\n\r\n    // Get current user positions for saving/restoring\r\n    getUserPositions() {\r\n        const positions = {};\r\n        this.users.forEach((user, userId) => {\r\n            positions[userId] = { x: user.x, y: user.y };\r\n        });\r\n        return positions;\r\n    }\r\n\r\n    // Restore user positions\r\n    setUserPositions(positions) {\r\n        Object.entries(positions).forEach(([userId, pos]) => {\r\n            if (this.users.has(userId)) {\r\n                this.updateUserPosition(userId, pos.x, pos.y);\r\n            }\r\n        });\r\n        this.updateAudioProximity();\r\n    }\r\n}","// src/renderer/js/server/ServerManager.js\r\nexport class ServerManager {\r\n    constructor() {\r\n        this.availableServers = [];\r\n        this.myServers = [];\r\n        this.favoriteServers = [];\r\n    }\r\n\r\n    async loadServerData() {\r\n        try {\r\n            const savedMyServers = localStorage.getItem('proximity-my-servers');\r\n            if (savedMyServers) {\r\n                this.myServers = JSON.parse(savedMyServers);\r\n            }\r\n            \r\n            const savedFavorites = localStorage.getItem('proximity-favorite-servers');\r\n            if (savedFavorites) {\r\n                this.favoriteServers = JSON.parse(savedFavorites);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error loading server data:', error);\r\n        }\r\n    }\r\n\r\n    saveServerData() {\r\n        try {\r\n            localStorage.setItem('proximity-my-servers', JSON.stringify(this.myServers));\r\n            localStorage.setItem('proximity-favorite-servers', JSON.stringify(this.favoriteServers));\r\n        } catch (error) {\r\n            console.error('Error saving server data:', error);\r\n        }\r\n    }\r\n\r\n    createServer(name, description) {\r\n        if (!window.proximityApp || !window.proximityApp.connectionManager.socket) {\r\n            throw new Error('Not connected to server');\r\n        }\r\n\r\n        window.proximityApp.connectionManager.emit('create-server', {\r\n            serverName: name,\r\n            serverDescription: description\r\n        });\r\n    }\r\n\r\n    joinServer(server) {\r\n        // Implementation for joining custom servers\r\n        // For now, we'll focus on the hub\r\n        console.log('Joining server:', server);\r\n    }\r\n\r\n    addToFavorites(serverId) {\r\n        if (!this.favoriteServers.includes(serverId)) {\r\n            this.favoriteServers.push(serverId);\r\n            this.saveServerData();\r\n        }\r\n    }\r\n\r\n    removeFromFavorites(serverId) {\r\n        this.favoriteServers = this.favoriteServers.filter(id => id !== serverId);\r\n        this.saveServerData();\r\n    }\r\n\r\n    addToMyServers(serverId) {\r\n        if (!this.myServers.includes(serverId)) {\r\n            this.myServers.push(serverId);\r\n            this.saveServerData();\r\n        }\r\n    }\r\n\r\n    updateAvailableServers(servers) {\r\n        this.availableServers = servers;\r\n        // Could emit event here for UI updates\r\n    }\r\n}","// src/renderer/js/settings/SettingsManager.js\r\nexport class SettingsManager {\r\n    constructor() {\r\n        this.settings = {\r\n            username: '',\r\n            userColor: 'purple',\r\n            audioGain: 50,\r\n            noiseSupression: true,\r\n            echoCancellation: true,\r\n            autoJoin: false,\r\n            muteHotkey: 'Ctrl+M',\r\n            deafenHotkey: 'Ctrl+D',\r\n            audioOutputDevice: ''\r\n        };\r\n        this.storageKey = 'proximity-settings';\r\n    }\r\n\r\n    async load() {\r\n        try {\r\n            const savedSettings = localStorage.getItem(this.storageKey);\r\n            if (savedSettings) {\r\n                this.settings = { ...this.settings, ...JSON.parse(savedSettings) };\r\n                console.log('Settings loaded:', this.settings);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error loading settings:', error);\r\n        }\r\n        \r\n        this.applyToUI();\r\n    }\r\n\r\n    save() {\r\n        try {\r\n            localStorage.setItem(this.storageKey, JSON.stringify(this.settings));\r\n            console.log('Settings saved');\r\n        } catch (error) {\r\n            console.error('Error saving settings:', error);\r\n        }\r\n    }\r\n\r\n    get(key) {\r\n        return this.settings[key];\r\n    }\r\n\r\n    set(key, value) {\r\n        this.settings[key] = value;\r\n        this.save();\r\n        this.applyToUI();\r\n    }\r\n\r\n    update(newSettings) {\r\n        this.settings = { ...this.settings, ...newSettings };\r\n        this.save();\r\n        this.applyToUI();\r\n    }\r\n\r\n    reset() {\r\n        this.settings = {\r\n            username: '',\r\n            userColor: 'purple',\r\n            audioGain: 50,\r\n            noiseSupression: true,\r\n            echoCancellation: true,\r\n            autoJoin: false,\r\n            muteHotkey: 'Ctrl+M',\r\n            deafenHotkey: 'Ctrl+D',\r\n            audioOutputDevice: ''\r\n        };\r\n        this.save();\r\n        this.applyToUI();\r\n    }\r\n\r\n    applyToUI() {\r\n        // Username\r\n        const usernameInput = document.getElementById('username');\r\n        if (usernameInput) {\r\n            usernameInput.value = this.settings.username;\r\n        }\r\n\r\n        // Audio gain\r\n        const audioGainSlider = document.getElementById('audioGain');\r\n        if (audioGainSlider) {\r\n            audioGainSlider.value = this.settings.audioGain;\r\n            const valueDisplay = document.querySelector('.slider-value');\r\n            if (valueDisplay) {\r\n                valueDisplay.textContent = `${this.settings.audioGain}%`;\r\n            }\r\n        }\r\n\r\n        // Checkboxes\r\n        const noiseSupressionCheck = document.getElementById('noiseSupression');\r\n        if (noiseSupressionCheck) {\r\n            noiseSupressionCheck.checked = this.settings.noiseSupression;\r\n        }\r\n\r\n        const echoCancellationCheck = document.getElementById('echoCancellation');\r\n        if (echoCancellationCheck) {\r\n            echoCancellationCheck.checked = this.settings.echoCancellation;\r\n        }\r\n\r\n        const autoJoinCheck = document.getElementById('autoJoin');\r\n        if (autoJoinCheck) {\r\n            autoJoinCheck.checked = this.settings.autoJoin;\r\n        }\r\n\r\n        // Color picker\r\n        const colorOptions = document.querySelectorAll('.color-option');\r\n        colorOptions.forEach(option => {\r\n            option.classList.remove('selected');\r\n            if (option.dataset.color === this.settings.userColor) {\r\n                option.classList.add('selected');\r\n            }\r\n        });\r\n\r\n        // Audio output device\r\n        const audioOutputDeviceSelect = document.getElementById('audioOutputDevice');\r\n        if (audioOutputDeviceSelect) {\r\n            audioOutputDeviceSelect.value = this.settings.audioOutputDevice || '';\r\n        }\r\n\r\n        // Apply audio gain to audio manager\r\n        if (window.proximityApp && window.proximityApp.audioManager) {\r\n            window.proximityApp.audioManager.setGain(this.settings.audioGain);\r\n        }\r\n    }\r\n}","// src/renderer/js/ui/UIManager.js - Updated with chat message delete and improved functionality\r\nexport class UIManager {\r\n    constructor() {\r\n        this.eventHandlers = {};\r\n        this.elements = {};\r\n        this.currentVoiceChannel = null;\r\n        this.currentTextChannel = 'diamond';\r\n    }\r\n\r\n    init() {\r\n        this.cacheElements();\r\n        this.setupEventListeners();\r\n        this.addHubToServers();\r\n        this.setupHomePageEvents();\r\n        this.setupChannelHandlers();\r\n    }\r\n\r\n    cacheElements() {\r\n        // Navigation\r\n        this.elements.navItems = document.querySelectorAll('.nav-item');\r\n        this.elements.pages = document.querySelectorAll('.page');\r\n        \r\n        // Connection status\r\n        this.elements.connectionIndicator = document.getElementById('connectionIndicator');\r\n        this.elements.connectionText = document.getElementById('connectionText');\r\n        \r\n        // Server view\r\n        this.elements.currentServerName = document.getElementById('currentServerName');\r\n        this.elements.participantsList = document.getElementById('participantsList');\r\n        \r\n        // Chat\r\n        this.elements.chatMessages = document.getElementById('chatMessages');\r\n        this.elements.messageInput = document.getElementById('messageInput');\r\n        this.elements.sendMessageBtn = document.getElementById('sendMessageBtn');\r\n        this.elements.currentChannelName = document.getElementById('currentChannelName');\r\n        this.elements.currentChannelDescription = document.getElementById('currentChannelDescription');\r\n        \r\n        // Voice controls\r\n        this.elements.muteButton = document.getElementById('muteButton');\r\n        this.elements.mapMuteButton = document.getElementById('mapMuteButton');\r\n        this.elements.leaveChannelBtn = document.getElementById('leaveChannelBtn');\r\n        \r\n        // Audio devices\r\n        this.elements.audioDeviceSelect = document.getElementById('audioDevice');\r\n        this.elements.audioOutputDeviceSelect = document.getElementById('audioOutputDevice');\r\n        \r\n        // Home page elements\r\n        this.elements.joinHubBtn = document.getElementById('joinHubBtn');\r\n        \r\n        // Channel lists\r\n        this.elements.textChannelsList = document.getElementById('textChannelsList');\r\n        this.elements.voiceChannelsList = document.getElementById('voiceChannelsList');\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // Navigation\r\n        this.elements.navItems.forEach(item => {\r\n            item.addEventListener('click', () => {\r\n                const page = item.dataset.page;\r\n                this.switchPage(page);\r\n                this.emit('page-change', page);\r\n            });\r\n        });\r\n\r\n        // Chat - Single event listener setup\r\n        if (this.elements.sendMessageBtn) {\r\n            this.elements.sendMessageBtn.addEventListener('click', () => {\r\n                this.sendChatMessage();\r\n            });\r\n        }\r\n\r\n        if (this.elements.messageInput) {\r\n            this.elements.messageInput.addEventListener('keypress', (e) => {\r\n                if (e.key === 'Enter') {\r\n                    this.sendChatMessage();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Voice controls\r\n        [this.elements.muteButton, this.elements.mapMuteButton].forEach(btn => {\r\n            if (btn) {\r\n                btn.addEventListener('click', () => {\r\n                    this.emit('mute-toggle');\r\n                });\r\n            }\r\n        });\r\n\r\n        // Leave button - single event listener\r\n        if (this.elements.leaveChannelBtn) {\r\n            this.elements.leaveChannelBtn.addEventListener('click', () => {\r\n                console.log('Leave button clicked in UI');\r\n                this.emit('leave-channel');\r\n            });\r\n        }\r\n    }\r\n\r\n    setupChannelHandlers() {\r\n        // Text channel handlers\r\n        const textChannels = document.querySelectorAll('[data-channel-type=\"text\"]');\r\n        textChannels.forEach(channel => {\r\n            channel.addEventListener('click', () => {\r\n                const channelId = channel.dataset.channelId;\r\n                this.switchToTextChannel(channelId);\r\n            });\r\n        });\r\n\r\n        // Voice channel handlers\r\n        const voiceChannelHeaders = document.querySelectorAll('.voice-channel-header');\r\n        voiceChannelHeaders.forEach(header => {\r\n            header.addEventListener('click', () => {\r\n                const channelData = header.closest('.voice-channel').dataset;\r\n                const channelId = channelData.channelId;\r\n                this.toggleVoiceChannel(channelId);\r\n            });\r\n        });\r\n    }\r\n\r\n    setupHomePageEvents() {\r\n        // Home page hub button\r\n        if (this.elements.joinHubBtn) {\r\n            this.elements.joinHubBtn.addEventListener('click', () => {\r\n                console.log('Home page hub button clicked');\r\n                this.emit('join-hub');\r\n            });\r\n        }\r\n    }\r\n\r\n    addHubToServers() {\r\n        // Add Community Hub to My Servers section\r\n        const myServersList = document.getElementById('myServersList');\r\n        if (myServersList) {\r\n            const hubServer = document.createElement('div');\r\n            hubServer.className = 'server-item';\r\n            hubServer.dataset.serverId = 'hub';\r\n            hubServer.innerHTML = `\r\n                <div class=\"server-icon\">üè¢</div>\r\n                <span class=\"server-name\">Community Hub</span>\r\n            `;\r\n            \r\n            hubServer.addEventListener('click', () => {\r\n                console.log('Server hub button clicked');\r\n                this.switchPage('server-view');\r\n                this.emit('join-hub');\r\n            });\r\n            \r\n            myServersList.appendChild(hubServer);\r\n        }\r\n    }\r\n\r\n    switchPage(pageName) {\r\n        console.log('Switching to page:', pageName);\r\n        \r\n        // Update navigation\r\n        this.elements.navItems.forEach(item => {\r\n            item.classList.toggle('active', item.dataset.page === pageName);\r\n        });\r\n\r\n        // Update pages\r\n        this.elements.pages.forEach(page => {\r\n            page.classList.toggle('active', page.id === `${pageName}-page`);\r\n        });\r\n\r\n        // Special hub handling\r\n        if (pageName === 'hub') {\r\n            document.getElementById('server-view-page').classList.add('active');\r\n        }\r\n    }\r\n\r\n    showServerView(server) {\r\n        this.switchPage('server-view');\r\n        \r\n        if (this.elements.currentServerName) {\r\n            this.elements.currentServerName.textContent = server.name;\r\n        }\r\n\r\n        // Set up hub channels if it's the hub\r\n        if (server.id === 'hub') {\r\n            this.setupHubChannels();\r\n        }\r\n    }\r\n\r\n    setupHubChannels() {\r\n        // Start in diamond text channel\r\n        this.switchToTextChannel('diamond');\r\n        this.currentVoiceChannel = null;\r\n    }\r\n\r\n    switchToTextChannel(channelId) {\r\n        console.log('Switching to text channel:', channelId);\r\n        \r\n        this.currentTextChannel = channelId;\r\n        \r\n        // Update text channel selection\r\n        const textChannels = document.querySelectorAll('[data-channel-type=\"text\"]');\r\n        textChannels.forEach(channel => {\r\n            channel.classList.toggle('active', channel.dataset.channelId === channelId);\r\n        });\r\n        \r\n        // Update chat UI\r\n        const channelNames = {\r\n            diamond: { name: 'üíé diamond', desc: 'Welcome to the diamond chat' },\r\n            spade: { name: '‚ô†Ô∏è spade', desc: 'Welcome to the spade chat' },\r\n            club: { name: '‚ô£Ô∏è club', desc: 'Welcome to the club chat' },\r\n            heart: { name: '‚ô•Ô∏è heart', desc: 'Welcome to the heart chat' }\r\n        };\r\n        \r\n        const channelInfo = channelNames[channelId] || channelNames.diamond;\r\n        \r\n        if (this.elements.currentChannelName) {\r\n            this.elements.currentChannelName.textContent = `# ${channelId}`;\r\n        }\r\n        if (this.elements.currentChannelDescription) {\r\n            this.elements.currentChannelDescription.textContent = channelInfo.desc;\r\n        }\r\n        if (this.elements.messageInput) {\r\n            this.elements.messageInput.placeholder = `Message #${channelId}`;\r\n        }\r\n        \r\n        // Show text chat view\r\n        this.switchToContentView('text-chat-view');\r\n        \r\n        // Emit channel change\r\n        this.emit('text-channel-change', channelId);\r\n    }\r\n\r\n    toggleVoiceChannel(channelId) {\r\n        console.log('Toggle voice channel:', channelId, 'Current:', this.currentVoiceChannel);\r\n        \r\n        if (this.currentVoiceChannel === channelId) {\r\n            // Already in this voice channel, do nothing\r\n            this.showNotification('Already in this voice channel', 'info');\r\n            return;\r\n        }\r\n        \r\n        // Leave current voice channel if in one\r\n        if (this.currentVoiceChannel) {\r\n            this.emit('leave-voice-channel', this.currentVoiceChannel);\r\n        }\r\n        \r\n        // Join new voice channel\r\n        this.currentVoiceChannel = channelId;\r\n        this.emit('join-voice-channel', channelId);\r\n        \r\n        // Update voice channel UI\r\n        this.updateVoiceChannelUI(channelId);\r\n        \r\n        // Update voice header but DON'T switch to voice view\r\n        const channelNames = {\r\n            'diamond-voice': 'üíé Diamond Voice',\r\n            'spade-voice': '‚ô†Ô∏è Spade Voice', \r\n            'club-voice': '‚ô£Ô∏è Club Voice',\r\n            'heart-voice': '‚ô•Ô∏è Heart Voice'\r\n        };\r\n        \r\n        const voiceChannelName = document.getElementById('currentVoiceChannelName');\r\n        if (voiceChannelName) {\r\n            voiceChannelName.textContent = channelNames[channelId] || 'üîä Voice Channel';\r\n        }\r\n    }\r\n\r\n    updateVoiceChannelUI(activeChannelId) {\r\n        // Update voice channel header states\r\n        const voiceChannelHeaders = document.querySelectorAll('.voice-channel-header');\r\n        voiceChannelHeaders.forEach(header => {\r\n            const channelData = header.closest('.voice-channel').dataset;\r\n            header.classList.toggle('active', channelData.channelId === activeChannelId);\r\n        });\r\n    }\r\n\r\n    switchToContentView(viewId) {\r\n        document.querySelectorAll('.content-view').forEach(view => {\r\n            view.classList.remove('active');\r\n        });\r\n        \r\n        const targetView = document.getElementById(viewId);\r\n        if (targetView) {\r\n            targetView.classList.add('active');\r\n        }\r\n    }\r\n\r\n    addVoiceParticipant(userId, username, userColor, channelId, isSelf = false) {\r\n        // Get the specific voice channel participants container\r\n        const channelKey = channelId.replace('-voice', '');\r\n        const participantsContainer = document.getElementById(`voiceParticipants-${channelKey}`);\r\n        \r\n        if (!participantsContainer) {\r\n            console.warn('Voice participants container not found for channel:', channelId);\r\n            return;\r\n        }\r\n\r\n        // Remove existing participant if present\r\n        this.removeVoiceParticipant(userId, channelId);\r\n\r\n        const participant = document.createElement('div');\r\n        participant.className = 'voice-participant';\r\n        participant.id = `voice-participant-${userId}-${channelKey}`;\r\n        \r\n        const micStatus = document.createElement('div');\r\n        micStatus.className = 'mic-status';\r\n        \r\n        const avatar = document.createElement('span');\r\n        avatar.className = 'participant-avatar';\r\n        avatar.textContent = this.getColorEmoji(userColor);\r\n        \r\n        const name = document.createElement('span');\r\n        name.textContent = username;\r\n        name.style.fontWeight = isSelf ? 'bold' : 'normal';\r\n        \r\n        participant.appendChild(micStatus);\r\n        participant.appendChild(avatar);\r\n        participant.appendChild(name);\r\n        \r\n        participantsContainer.appendChild(participant);\r\n        \r\n        console.log(`Added voice participant ${username} to ${channelId}`);\r\n    }\r\n\r\n    removeVoiceParticipant(userId, channelId) {\r\n        if (channelId) {\r\n            const channelKey = channelId.replace('-voice', '');\r\n            const participant = document.getElementById(`voice-participant-${userId}-${channelKey}`);\r\n            if (participant) {\r\n                participant.remove();\r\n            }\r\n        } else {\r\n            // Remove from all channels if no specific channel provided\r\n            const allParticipants = document.querySelectorAll(`[id^=\"voice-participant-${userId}-\"]`);\r\n            allParticipants.forEach(p => p.remove());\r\n        }\r\n    }\r\n\r\n    clearVoiceParticipants(channelId) {\r\n        if (channelId) {\r\n            const channelKey = channelId.replace('-voice', '');\r\n            const participantsContainer = document.getElementById(`voiceParticipants-${channelKey}`);\r\n            if (participantsContainer) {\r\n                participantsContainer.innerHTML = '';\r\n            }\r\n        } else {\r\n            // Clear all voice channels\r\n            ['diamond', 'spade', 'club', 'heart'].forEach(channel => {\r\n                const container = document.getElementById(`voiceParticipants-${channel}`);\r\n                if (container) {\r\n                    container.innerHTML = '';\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    addParticipant(userId, stream, isSelf = false, username = 'Anonymous', userColor = 'purple') {\r\n        // This is for the main voice view participants list (REMOVED - not needed)\r\n        // We only show participants under voice channels now\r\n        return;\r\n    }\r\n\r\n    removeParticipant(userId) {\r\n        // Remove from main participants list (REMOVED - not needed)\r\n        return;\r\n    }\r\n\r\n    clearParticipants() {\r\n        // Clear main participants list (REMOVED - not needed)\r\n        return;\r\n    }\r\n\r\n    updateMuteStatus(isMuted) {\r\n        [this.elements.muteButton, this.elements.mapMuteButton].forEach(button => {\r\n            if (button) {\r\n                const textSpan = button.querySelector('.text');\r\n                const iconSpan = button.querySelector('.icon');\r\n                \r\n                if (textSpan) textSpan.textContent = isMuted ? 'Unmute' : 'Mute';\r\n                if (iconSpan) iconSpan.textContent = isMuted ? 'üîá' : 'üé§';\r\n                \r\n                button.classList.toggle('muted', isMuted);\r\n            }\r\n        });\r\n\r\n        // Update mic status in voice participants\r\n        const myParticipants = document.querySelectorAll(`[id*=\"voice-participant-${this.getUserId()}-\"]`);\r\n        myParticipants.forEach(participant => {\r\n            const micStatus = participant.querySelector('.mic-status');\r\n            if (micStatus) {\r\n                micStatus.classList.toggle('muted', isMuted);\r\n            }\r\n        });\r\n    }\r\n\r\n    updateUserMicStatus(userId, isMuted) {\r\n        // Update mic status for a specific user in voice participants\r\n        const userParticipants = document.querySelectorAll(`[id*=\"voice-participant-${userId}-\"]`);\r\n        userParticipants.forEach(participant => {\r\n            const micStatus = participant.querySelector('.mic-status');\r\n            if (micStatus) {\r\n                micStatus.classList.toggle('muted', isMuted);\r\n            }\r\n        });\r\n    }\r\n\r\n    updateConnectionStatus(status, text) {\r\n        if (this.elements.connectionIndicator && this.elements.connectionText) {\r\n            this.elements.connectionIndicator.classList.remove('online', 'offline', 'connecting');\r\n            this.elements.connectionIndicator.classList.add(status);\r\n            this.elements.connectionText.textContent = text;\r\n        }\r\n    }\r\n\r\n    // Chat message sender\r\n    sendChatMessage() {\r\n        if (!this.elements.messageInput) return;\r\n        \r\n        const message = this.elements.messageInput.value.trim();\r\n        if (!message) return;\r\n        \r\n        console.log('UI sending message:', message, 'to channel:', this.currentTextChannel);\r\n        this.emit('send-message', { message, channel: this.currentTextChannel });\r\n        this.elements.messageInput.value = '';\r\n    }\r\n\r\n    // ENHANCED: Add chat message with delete functionality\r\n    addChatMessage(messageData) {\r\n        if (!this.elements.chatMessages) return;\r\n\r\n        const messageElement = document.createElement('div');\r\n        messageElement.className = 'message';\r\n        messageElement.id = `message-${messageData.id}`;\r\n\r\n        const messageHeader = document.createElement('div');\r\n        messageHeader.className = 'message-header';\r\n\r\n        const author = document.createElement('span');\r\n        author.className = 'message-author';\r\n        author.textContent = messageData.username;\r\n\r\n        const time = document.createElement('span');\r\n        time.className = 'message-timestamp';\r\n        time.textContent = new Date(messageData.timestamp).toLocaleTimeString();\r\n\r\n        messageHeader.appendChild(author);\r\n        messageHeader.appendChild(time);\r\n\r\n        const content = document.createElement('div');\r\n        content.className = 'message-content';\r\n        content.textContent = messageData.message;\r\n\r\n        // Add delete button for own messages\r\n        const isOwnMessage = messageData.userId === this.getUserId();\r\n        if (isOwnMessage) {\r\n            const deleteBtn = document.createElement('button');\r\n            deleteBtn.className = 'message-delete-btn';\r\n            deleteBtn.innerHTML = 'üóëÔ∏è';\r\n            deleteBtn.title = 'Delete message';\r\n            deleteBtn.style.display = 'none'; // Hidden by default\r\n            \r\n            deleteBtn.addEventListener('click', (e) => {\r\n                e.stopPropagation();\r\n                this.showDeleteConfirmation(messageData.id);\r\n            });\r\n            \r\n            messageElement.appendChild(deleteBtn);\r\n            \r\n            // Show delete button on hover\r\n            messageElement.addEventListener('mouseenter', () => {\r\n                deleteBtn.style.display = 'block';\r\n            });\r\n            \r\n            messageElement.addEventListener('mouseleave', () => {\r\n                deleteBtn.style.display = 'none';\r\n            });\r\n        }\r\n\r\n        messageElement.appendChild(messageHeader);\r\n        messageElement.appendChild(content);\r\n\r\n        this.elements.chatMessages.appendChild(messageElement);\r\n        this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;\r\n    }\r\n\r\n    showDeleteConfirmation(messageId) {\r\n        const confirmed = confirm('Do you want to delete this message?');\r\n        if (confirmed) {\r\n            this.emit('delete-message', messageId);\r\n        }\r\n    }\r\n\r\n    removeChatMessage(messageId) {\r\n        const messageElement = document.getElementById(`message-${messageId}`);\r\n        if (messageElement) {\r\n            messageElement.remove();\r\n        }\r\n    }\r\n\r\n    async populateAudioDevices() {\r\n        if (!this.elements.audioDeviceSelect || !this.elements.audioOutputDeviceSelect) return;\r\n        \r\n        try {\r\n            const devices = await navigator.mediaDevices.enumerateDevices();\r\n            const audioInputs = devices.filter(device => device.kind === 'audioinput');\r\n            const audioOutputs = devices.filter(device => device.kind === 'audiooutput');\r\n\r\n            this.elements.audioDeviceSelect.innerHTML = '<option value=\"\">Select Audio Device</option>';\r\n            this.elements.audioOutputDeviceSelect.innerHTML = '<option value=\"\">Select Output Device</option>';\r\n\r\n            audioInputs.forEach((device, index) => {\r\n                const option = document.createElement('option');\r\n                option.value = device.deviceId;\r\n                option.textContent = device.label || `Microphone ${index + 1}`;\r\n                this.elements.audioDeviceSelect.appendChild(option);\r\n            });\r\n\r\n            audioOutputs.forEach((device, index) => {\r\n                const option = document.createElement('option');\r\n                option.value = device.deviceId;\r\n                option.textContent = device.label || `Speaker ${index + 1}`;\r\n                this.elements.audioOutputDeviceSelect.appendChild(option);\r\n            });\r\n        } catch (error) {\r\n            console.error('Error populating audio devices:', error);\r\n        }\r\n    }\r\n\r\n    showNotification(message, type = 'info') {\r\n        console.log(`Notification [${type}]: ${message}`);\r\n        \r\n        const notification = document.createElement('div');\r\n        notification.className = `notification ${type}`;\r\n        notification.textContent = message;\r\n        \r\n        Object.assign(notification.style, {\r\n            position: 'fixed',\r\n            top: '20px',\r\n            right: '20px',\r\n            padding: '12px 20px',\r\n            borderRadius: '8px',\r\n            color: 'white',\r\n            fontWeight: '500',\r\n            zIndex: '9999',\r\n            opacity: '0',\r\n            transform: 'translateX(100%)',\r\n            transition: 'all 0.3s ease'\r\n        });\r\n        \r\n        const colors = {\r\n            success: '#10b981',\r\n            error: '#ef4444',\r\n            warning: '#f59e0b',\r\n            info: '#6b46c1'\r\n        };\r\n        notification.style.backgroundColor = colors[type] || colors.info;\r\n        \r\n        document.body.appendChild(notification);\r\n        \r\n        setTimeout(() => {\r\n            notification.style.opacity = '1';\r\n            notification.style.transform = 'translateX(0)';\r\n        }, 10);\r\n        \r\n        setTimeout(() => {\r\n            notification.style.opacity = '0';\r\n            notification.style.transform = 'translateX(100%)';\r\n            setTimeout(() => {\r\n                if (notification.parentNode) {\r\n                    document.body.removeChild(notification);\r\n                }\r\n            }, 300);\r\n        }, 3000);\r\n    }\r\n\r\n    getColorEmoji(color) {\r\n        const colorEmojis = {\r\n            blue: 'üîµ',\r\n            green: 'üü¢', \r\n            purple: 'üü£',\r\n            red: 'üî¥',\r\n            orange: 'üü†',\r\n            pink: 'ü©∑',\r\n            indigo: 'üíú',\r\n            cyan: 'üîπ'\r\n        };\r\n        return colorEmojis[color] || colorEmojis['purple'];\r\n    }\r\n\r\n    getUserId() {\r\n        return window.proximityApp ? window.proximityApp.myUserId : null;\r\n    }\r\n\r\n    getCurrentVoiceChannel() {\r\n        return this.currentVoiceChannel;\r\n    }\r\n\r\n    getCurrentTextChannel() {\r\n        return this.currentTextChannel;\r\n    }\r\n\r\n    // Event system\r\n    on(event, callback) {\r\n        if (!this.eventHandlers[event]) {\r\n            this.eventHandlers[event] = [];\r\n        }\r\n        this.eventHandlers[event].push(callback);\r\n    }\r\n\r\n    emit(event, data) {\r\n        if (this.eventHandlers[event]) {\r\n            this.eventHandlers[event].forEach(callback => callback(data));\r\n        }\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// src/renderer/js/app.js - Fixed navigation and channel persistence\r\nimport { ConnectionManager } from './core/ConnectionManager.js';\r\nimport { UIManager } from './ui/UIManager.js';\r\nimport { AudioManager } from './audio/AudioManager.js';\r\nimport { ProximityMap } from './proximity/ProximityMap.js';\r\nimport { ServerManager } from './server/ServerManager.js';\r\nimport { ChatManager } from './chat/ChatManager.js';\r\nimport { SettingsManager } from './settings/SettingsManager.js';\r\n\r\n// Try Railway first, fallback to localhost for development\r\nconst SERVER_URL = 'https://myserver2-production.up.railway.app';\r\nconst FALLBACK_URL = 'http://localhost:3000';\r\n\r\nclass ProximityApp {\r\n    constructor() {\r\n        console.log('ProximityApp initializing...');\r\n        \r\n        // Core managers\r\n        this.connectionManager = new ConnectionManager(SERVER_URL);\r\n        this.uiManager = new UIManager();\r\n        this.audioManager = new AudioManager();\r\n        this.settingsManager = new SettingsManager();\r\n        this.serverManager = new ServerManager();\r\n        this.chatManager = new ChatManager();\r\n        this.proximityMap = null;\r\n        \r\n        // State\r\n        this.currentServer = null;\r\n        this.currentTextChannel = 'diamond';\r\n        this.currentVoiceChannel = null;\r\n        this.myUserId = null;\r\n        this.isInHub = false;\r\n        this.hubUsers = [];\r\n        \r\n        // Global chat message storage (persistent across sessions)\r\n        this.globalChatHistory = this.loadGlobalChatHistory();\r\n        \r\n        this.init();\r\n    }\r\n\r\n    loadGlobalChatHistory() {\r\n        try {\r\n            const saved = localStorage.getItem('proximity-chat-history');\r\n            return saved ? JSON.parse(saved) : {\r\n                diamond: [],\r\n                spade: [],\r\n                club: [],\r\n                heart: []\r\n            };\r\n        } catch (error) {\r\n            console.error('Failed to load chat history:', error);\r\n            return {\r\n                diamond: [],\r\n                spade: [],\r\n                club: [],\r\n                heart: []\r\n            };\r\n        }\r\n    }\r\n\r\n    saveGlobalChatHistory() {\r\n        try {\r\n            localStorage.setItem('proximity-chat-history', JSON.stringify(this.globalChatHistory));\r\n        } catch (error) {\r\n            console.error('Failed to save chat history:', error);\r\n        }\r\n    }\r\n\r\n    async init() {\r\n        try {\r\n            // Initialize settings first\r\n            await this.settingsManager.load();\r\n            \r\n            // Initialize UI\r\n            this.uiManager.init();\r\n            this.setupEventListeners();\r\n            \r\n            // Initialize proximity map\r\n            this.proximityMap = new ProximityMap(\r\n                document.getElementById('proximityMap'), \r\n                this\r\n            );\r\n            \r\n            // Setup map controls\r\n            this.setupMapControls();\r\n            \r\n            // Setup settings controls\r\n            this.setupSettingsControls();\r\n            \r\n            // Setup map buttons for voice channels\r\n            this.setupMapButtons();\r\n            \r\n            // Setup mini map modal\r\n            this.setupMiniMapModal();\r\n            \r\n            // Try to connect to server with fallback\r\n            await this.connectWithFallback();\r\n            \r\n            console.log('ProximityApp initialized successfully');\r\n            \r\n        } catch (error) {\r\n            console.error('Failed to initialize app:', error);\r\n            this.uiManager.showNotification('Failed to initialize app', 'error');\r\n        }\r\n    }\r\n\r\n    async connectWithFallback() {\r\n        try {\r\n            await this.connectionManager.connect();\r\n            this.myUserId = this.connectionManager.socket.id;\r\n            this.setupConnectionHandlers();\r\n        } catch (error) {\r\n            console.warn('Railway server failed, trying localhost...', error);\r\n            try {\r\n                this.connectionManager = new ConnectionManager(FALLBACK_URL);\r\n                await this.connectionManager.connect();\r\n                this.myUserId = this.connectionManager.socket.id;\r\n                this.setupConnectionHandlers();\r\n                this.uiManager.showNotification('Connected to local server', 'warning');\r\n            } catch (fallbackError) {\r\n                console.error('Both servers failed:', fallbackError);\r\n                this.uiManager.showNotification('Could not connect to any server', 'error');\r\n            }\r\n        }\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // Navigation - FIXED: Don't leave voice channel when switching pages\r\n        this.uiManager.on('page-change', (page) => this.handlePageChange(page));\r\n        this.uiManager.on('join-hub', () => this.joinHub());\r\n        this.uiManager.on('leave-channel', () => this.leaveCurrentChannel());\r\n        this.uiManager.on('mute-toggle', () => this.audioManager.toggleMute());\r\n        \r\n        // Channel events\r\n        this.uiManager.on('text-channel-change', (channelId) => this.switchTextChannel(channelId));\r\n        this.uiManager.on('join-voice-channel', (channelId) => this.joinVoiceChannel(channelId));\r\n        this.uiManager.on('leave-voice-channel', (channelId) => this.leaveVoiceChannel(channelId));\r\n        \r\n        // Chat events\r\n        this.uiManager.on('send-message', (data) => {\r\n            console.log('App received send-message event:', data);\r\n            this.sendChatMessage(data.message, data.channel);\r\n        });\r\n        \r\n        this.uiManager.on('delete-message', (messageId) => this.deleteMessage(messageId));\r\n        \r\n        // Settings\r\n        this.uiManager.on('settings-change', (settings) => this.settingsManager.update(settings));\r\n    }\r\n\r\n    setupMiniMapModal() {\r\n        // Create mini map modal\r\n        const modalHTML = `\r\n            <div id=\"miniMapModal\" class=\"mini-map-modal\" style=\"display: none;\">\r\n                <div class=\"mini-map-content\">\r\n                    <div class=\"mini-map-header\">\r\n                        <h4>Channel Map</h4>\r\n                        <button id=\"closeMiniMap\" class=\"close-btn\">√ó</button>\r\n                    </div>\r\n                    <canvas id=\"miniProximityMap\" width=\"400\" height=\"300\"></canvas>\r\n                    <div class=\"mini-map-controls\">\r\n                        <div class=\"proximity-info\">\r\n                            <span>Range: <span id=\"miniProximityRange\">100px</span></span>\r\n                            <input type=\"range\" id=\"miniProximitySlider\" min=\"50\" max=\"300\" value=\"100\" class=\"proximity-slider\">\r\n                        </div>\r\n                        <button id=\"miniCenterBtn\" class=\"btn secondary\">Center</button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        `;\r\n        \r\n        document.body.insertAdjacentHTML('beforeend', modalHTML);\r\n        \r\n        // Setup mini map controls\r\n        const closeMiniMap = document.getElementById('closeMiniMap');\r\n        const miniProximitySlider = document.getElementById('miniProximitySlider');\r\n        const miniProximityRange = document.getElementById('miniProximityRange');\r\n        const miniCenterBtn = document.getElementById('miniCenterBtn');\r\n        \r\n        if (closeMiniMap) {\r\n            closeMiniMap.addEventListener('click', () => this.closeMiniMap());\r\n        }\r\n        \r\n        if (miniProximitySlider && miniProximityRange) {\r\n            miniProximitySlider.addEventListener('input', (e) => {\r\n                const range = parseInt(e.target.value);\r\n                miniProximityRange.textContent = `${range}px`;\r\n                if (this.proximityMap) {\r\n                    this.proximityMap.setProximityRange(range);\r\n                }\r\n                // Sync with main slider\r\n                const mainSlider = document.getElementById('proximitySlider');\r\n                if (mainSlider) {\r\n                    mainSlider.value = range;\r\n                    document.getElementById('proximityRange').textContent = `${range}px`;\r\n                }\r\n            });\r\n        }\r\n        \r\n        if (miniCenterBtn) {\r\n            miniCenterBtn.addEventListener('click', () => {\r\n                if (this.proximityMap) {\r\n                    this.proximityMap.centerMyPosition();\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Click outside to close\r\n        const modal = document.getElementById('miniMapModal');\r\n        if (modal) {\r\n            modal.addEventListener('click', (e) => {\r\n                if (e.target === modal) {\r\n                    this.closeMiniMap();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    openMiniMap() {\r\n        if (!this.currentVoiceChannel) {\r\n            this.uiManager.showNotification('Join a voice channel first', 'warning');\r\n            return;\r\n        }\r\n        \r\n        const modal = document.getElementById('miniMapModal');\r\n        if (modal) {\r\n            modal.style.display = 'flex';\r\n            \r\n            // Initialize mini proximity map\r\n            const miniCanvas = document.getElementById('miniProximityMap');\r\n            if (miniCanvas && this.proximityMap) {\r\n                // Copy main map state to mini map\r\n                this.miniProximityMap = new ProximityMap(miniCanvas, this);\r\n                \r\n                // Copy users from main map\r\n                this.proximityMap.users.forEach((user, userId) => {\r\n                    this.miniProximityMap.addUser(userId, user.username, user.isSelf, user.audioElement);\r\n                    this.miniProximityMap.updateUserPosition(userId, user.x, user.y);\r\n                    this.miniProximityMap.updateUserColor(userId, user.color);\r\n                });\r\n                \r\n                this.miniProximityMap.setProximityRange(this.proximityMap.proximityRange);\r\n            }\r\n        }\r\n    }\r\n\r\n    closeMiniMap() {\r\n        const modal = document.getElementById('miniMapModal');\r\n        if (modal) {\r\n            modal.style.display = 'none';\r\n        }\r\n        if (this.miniProximityMap) {\r\n            this.miniProximityMap = null;\r\n        }\r\n    }\r\n\r\n    setupMapButtons() {\r\n        // Setup map buttons for voice channels\r\n        const mapButtons = document.querySelectorAll('.map-button');\r\n        mapButtons.forEach(button => {\r\n            button.addEventListener('click', (e) => {\r\n                e.stopPropagation(); // Prevent voice channel toggle\r\n                const voiceChannel = button.dataset.voiceChannel;\r\n                \r\n                if (this.currentVoiceChannel !== voiceChannel) {\r\n                    this.uiManager.showNotification('Join the voice channel first to access the map', 'warning');\r\n                    return;\r\n                }\r\n                \r\n                // Open mini map instead of switching pages\r\n                this.openMiniMap();\r\n            });\r\n        });\r\n    }\r\n\r\n    // FIXED: Don't remove duplicate send function\r\n    sendChatMessage(message, channel) {\r\n        if (!message.trim()) return;\r\n\r\n        if (!this.connectionManager.socket) {\r\n            console.error('Not connected to server');\r\n            return;\r\n        }\r\n\r\n        if (!this.isInHub) {\r\n            console.error('Not in hub');\r\n            return;\r\n        }\r\n\r\n        const username = this.settingsManager.get('username') || 'Anonymous';\r\n        const targetChannel = channel || this.currentTextChannel;\r\n        \r\n        console.log('Sending chat message:', message, 'to channel:', targetChannel);\r\n\r\n        // Create message with unique ID\r\n        const messageData = {\r\n            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),\r\n            roomId: 'hub',\r\n            message: message,\r\n            username: username,\r\n            channel: targetChannel,\r\n            timestamp: Date.now(),\r\n            userId: this.myUserId\r\n        };\r\n\r\n        this.connectionManager.socket.emit('send-chat-message', messageData);\r\n    }\r\n\r\n    deleteMessage(messageId) {\r\n        if (!this.connectionManager.socket) {\r\n            console.error('Not connected to server');\r\n            return;\r\n        }\r\n\r\n        console.log('Deleting message:', messageId);\r\n\r\n        this.connectionManager.socket.emit('delete-chat-message', {\r\n            messageId: messageId,\r\n            userId: this.myUserId\r\n        });\r\n    }\r\n\r\n    setupMapControls() {\r\n        // Proximity slider\r\n        const proximitySlider = document.getElementById('proximitySlider');\r\n        const proximityRangeDisplay = document.getElementById('proximityRange');\r\n        \r\n        if (proximitySlider && proximityRangeDisplay) {\r\n            proximitySlider.addEventListener('input', (e) => {\r\n                const range = parseInt(e.target.value);\r\n                proximityRangeDisplay.textContent = `${range}px`;\r\n                if (this.proximityMap) {\r\n                    this.proximityMap.setProximityRange(range);\r\n                }\r\n                // Sync with mini map slider\r\n                const miniSlider = document.getElementById('miniProximitySlider');\r\n                if (miniSlider) {\r\n                    miniSlider.value = range;\r\n                    document.getElementById('miniProximityRange').textContent = `${range}px`;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Center map button\r\n        const centerMapBtn = document.getElementById('centerMapBtn');\r\n        if (centerMapBtn) {\r\n            centerMapBtn.addEventListener('click', () => {\r\n                if (this.proximityMap) {\r\n                    this.proximityMap.centerMyPosition();\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Test bot toggle\r\n        const toggleTestBotBtn = document.getElementById('toggleTestBot');\r\n        if (toggleTestBotBtn) {\r\n            toggleTestBotBtn.addEventListener('click', () => {\r\n                if (this.proximityMap) {\r\n                    if (this.proximityMap.testBotId) {\r\n                        this.proximityMap.removeTestBot();\r\n                        toggleTestBotBtn.innerHTML = '<span class=\"icon\">ü§ñ</span><span class=\"text\">Add Test Bot</span>';\r\n                        this.uiManager.showNotification('Test bot removed', 'info');\r\n                    } else {\r\n                        this.proximityMap.addTestBot();\r\n                        toggleTestBotBtn.innerHTML = '<span class=\"icon\">ü§ñ</span><span class=\"text\">Remove Test Bot</span>';\r\n                        this.uiManager.showNotification('Test bot added - move around to test proximity!', 'success');\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Map leave channel button\r\n        const mapLeaveChannelBtn = document.getElementById('mapLeaveChannelBtn');\r\n        if (mapLeaveChannelBtn) {\r\n            mapLeaveChannelBtn.addEventListener('click', () => {\r\n                console.log('Map leave button clicked');\r\n                this.leaveCurrentChannel();\r\n            });\r\n        }\r\n    }\r\n\r\n    setupSettingsControls() {\r\n        // Username input\r\n        const usernameInput = document.getElementById('username');\r\n        if (usernameInput) {\r\n            usernameInput.addEventListener('input', (e) => {\r\n                this.settingsManager.set('username', e.target.value.trim());\r\n                this.updateParticipantName();\r\n            });\r\n        }\r\n\r\n        // Audio device selectors - FIXED: Prevent auto-switching on page change\r\n        const audioDeviceSelect = document.getElementById('audioDevice');\r\n        if (audioDeviceSelect) {\r\n            audioDeviceSelect.addEventListener('change', (e) => {\r\n                if (e.target.value && !this.isPopulatingDevices) {\r\n                    this.settingsManager.set('audioInputDevice', e.target.value);\r\n                    this.audioManager.changeInputDevice(e.target.value)\r\n                        .then(() => this.uiManager.showNotification('Audio input device changed', 'success'))\r\n                        .catch(() => this.uiManager.showNotification('Failed to change audio input device', 'error'));\r\n                }\r\n            });\r\n        }\r\n\r\n        const audioOutputDeviceSelect = document.getElementById('audioOutputDevice');\r\n        if (audioOutputDeviceSelect) {\r\n            audioOutputDeviceSelect.addEventListener('change', (e) => {\r\n                if (e.target.value && !this.isPopulatingDevices) {\r\n                    this.settingsManager.set('audioOutputDevice', e.target.value);\r\n                    this.audioManager.changeOutputDevice(e.target.value)\r\n                        .then(() => this.uiManager.showNotification('Audio output device changed', 'success'))\r\n                        .catch(() => this.uiManager.showNotification('Failed to change audio output device', 'error'));\r\n                }\r\n            });\r\n        }\r\n\r\n        // Audio gain slider\r\n        const audioGainSlider = document.getElementById('audioGain');\r\n        if (audioGainSlider) {\r\n            audioGainSlider.addEventListener('input', (e) => {\r\n                this.settingsManager.set('audioGain', parseInt(e.target.value));\r\n                this.audioManager.setGain(parseInt(e.target.value));\r\n                \r\n                const valueDisplay = document.querySelector('.slider-value');\r\n                if (valueDisplay) {\r\n                    valueDisplay.textContent = `${e.target.value}%`;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Color picker\r\n        const colorOptions = document.querySelectorAll('.color-option');\r\n        colorOptions.forEach(option => {\r\n            option.addEventListener('click', (e) => {\r\n                const selectedColor = e.target.dataset.color;\r\n                colorOptions.forEach(opt => opt.classList.remove('selected'));\r\n                option.classList.add('selected');\r\n                \r\n                this.settingsManager.set('userColor', selectedColor);\r\n                this.updateParticipantColor();\r\n                this.uiManager.showNotification(`User color changed to ${selectedColor}`, 'success');\r\n            });\r\n        });\r\n\r\n        // Checkboxes\r\n        const noiseSupressionCheck = document.getElementById('noiseSupression');\r\n        if (noiseSupressionCheck) {\r\n            noiseSupressionCheck.addEventListener('change', (e) => {\r\n                this.settingsManager.set('noiseSupression', e.target.checked);\r\n            });\r\n        }\r\n\r\n        const echoCancellationCheck = document.getElementById('echoCancellation');\r\n        if (echoCancellationCheck) {\r\n            echoCancellationCheck.addEventListener('change', (e) => {\r\n                this.settingsManager.set('echoCancellation', e.target.checked);\r\n            });\r\n        }\r\n\r\n        const autoJoinCheck = document.getElementById('autoJoin');\r\n        if (autoJoinCheck) {\r\n            autoJoinCheck.addEventListener('change', (e) => {\r\n                this.settingsManager.set('autoJoin', e.target.checked);\r\n            });\r\n        }\r\n\r\n        // Test buttons\r\n        const testMicrophoneBtn = document.getElementById('testMicrophone');\r\n        if (testMicrophoneBtn) {\r\n            testMicrophoneBtn.addEventListener('click', () => this.testMicrophone());\r\n        }\r\n\r\n        const testOutputButton = document.getElementById('testOutputButton');\r\n        if (testOutputButton) {\r\n            testOutputButton.addEventListener('click', () => this.testOutput());\r\n        }\r\n\r\n        const resetSettingsBtn = document.getElementById('resetSettings');\r\n        if (resetSettingsBtn) {\r\n            resetSettingsBtn.addEventListener('click', () => {\r\n                if (confirm('Are you sure you want to reset all settings to defaults?')) {\r\n                    this.settingsManager.reset();\r\n                    this.uiManager.showNotification('Settings reset to defaults', 'success');\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    setupConnectionHandlers() {\r\n        const socket = this.connectionManager.socket;\r\n        \r\n        socket.on('connect', () => {\r\n            console.log('Connected to server');\r\n            this.myUserId = socket.id;\r\n            this.uiManager.updateConnectionStatus('online', 'Connected');\r\n            this.uiManager.showNotification('Connected to server', 'success');\r\n        });\r\n\r\n        socket.on('disconnect', () => {\r\n            this.uiManager.updateConnectionStatus('offline', 'Disconnected');\r\n            this.uiManager.showNotification('Disconnected from server', 'warning');\r\n        });\r\n\r\n        // Hub events\r\n        socket.on('hub-users', (users) => {\r\n            console.log('Hub users received:', users);\r\n            this.handleHubUsers(users);\r\n        });\r\n\r\n        socket.on('user-joined-hub', (user) => {\r\n            console.log('User joined hub:', user);\r\n            this.uiManager.showNotification(`${user.username} joined the hub`, 'info');\r\n            this.handleUserJoined(user);\r\n        });\r\n\r\n        socket.on('user-left-hub', (user) => {\r\n            console.log('User left hub:', user);\r\n            this.uiManager.showNotification(`${user.username} left the hub`, 'info');\r\n            this.handleUserLeft(user);\r\n        });\r\n\r\n        // Voice events\r\n        socket.on('offer', ({ offer, from }) => this.audioManager.handleOffer(offer, from));\r\n        socket.on('answer', ({ answer, from }) => this.audioManager.handleAnswer(answer, from));\r\n        socket.on('ice-candidate', ({ candidate, from }) => this.audioManager.handleIceCandidate(candidate, from));\r\n        \r\n        // Mic status events\r\n        socket.on('user-mic-status', ({ userId, isMuted }) => {\r\n            this.uiManager.updateUserMicStatus(userId, isMuted);\r\n        });\r\n        \r\n        // Chat events - FIXED: Store messages globally and permanently\r\n        socket.on('chat-message', (data) => {\r\n            console.log('Chat message received:', data);\r\n            const channel = data.channel || 'diamond';\r\n            \r\n            // Store message globally and permanently\r\n            if (!this.globalChatHistory[channel]) {\r\n                this.globalChatHistory[channel] = [];\r\n            }\r\n            \r\n            const messageData = {\r\n                id: data.id,\r\n                username: data.username,\r\n                message: data.message,\r\n                timestamp: data.timestamp,\r\n                userId: data.userId\r\n            };\r\n            \r\n            this.globalChatHistory[channel].push(messageData);\r\n            this.saveGlobalChatHistory();\r\n            \r\n            // Show message if it's for current channel\r\n            if (channel === this.currentTextChannel) {\r\n                this.uiManager.addChatMessage(messageData);\r\n            }\r\n        });\r\n        \r\n        socket.on('message-deleted', (data) => {\r\n            console.log('Message deleted:', data);\r\n            const { messageId, channel } = data;\r\n            \r\n            // Remove from global history\r\n            if (this.globalChatHistory[channel]) {\r\n                this.globalChatHistory[channel] = this.globalChatHistory[channel].filter(msg => msg.id !== messageId);\r\n                this.saveGlobalChatHistory();\r\n            }\r\n            \r\n            // Remove from UI if in current channel\r\n            if (channel === this.currentTextChannel) {\r\n                this.uiManager.removeChatMessage(messageId);\r\n            }\r\n        });\r\n        \r\n        // Position events\r\n        socket.on('position-update', ({ userId, x, y }) => {\r\n            if (this.proximityMap) {\r\n                this.proximityMap.updateUserPosition(userId, x, y);\r\n            }\r\n            if (this.miniProximityMap) {\r\n                this.miniProximityMap.updateUserPosition(userId, x, y);\r\n            }\r\n        });\r\n    }\r\n\r\n    async joinHub() {\r\n        try {\r\n            console.log('Joining hub...');\r\n            \r\n            const username = this.settingsManager.get('username') || 'Anonymous';\r\n            const userColor = this.settingsManager.get('userColor') || 'purple';\r\n            \r\n            // Join the hub room\r\n            this.connectionManager.socket.emit('join-hub', {\r\n                username,\r\n                userColor\r\n            });\r\n            \r\n            this.isInHub = true;\r\n            this.currentServer = { id: 'hub', name: 'Community Hub' };\r\n            this.currentTextChannel = 'diamond';\r\n            // DON'T reset voice channel - preserve it across navigation\r\n            \r\n            // Update UI - start in text channel\r\n            this.uiManager.showServerView(this.currentServer);\r\n            \r\n            // Load persistent chat history\r\n            this.loadChatForCurrentChannel();\r\n            \r\n            // Hide leave channel button initially (unless in voice)\r\n            this.updateLeaveButtonVisibility();\r\n            \r\n            this.uiManager.showNotification('Joined Community Hub', 'success');\r\n            \r\n        } catch (error) {\r\n            console.error('Failed to join hub:', error);\r\n            this.uiManager.showNotification('Failed to join hub', 'error');\r\n        }\r\n    }\r\n\r\n    // FIXED: Load persistent chat history when switching channels\r\n    switchTextChannel(channelId) {\r\n        console.log('Switching text channel to:', channelId);\r\n        this.currentTextChannel = channelId;\r\n        this.loadChatForCurrentChannel();\r\n        this.chatManager.setCurrentChannel(channelId);\r\n    }\r\n\r\n    loadChatForCurrentChannel() {\r\n        // Clear current chat\r\n        const chatMessages = document.getElementById('chatMessages');\r\n        if (chatMessages) {\r\n            chatMessages.innerHTML = `\r\n                <div class=\"welcome-message\">\r\n                    <p>Welcome to the ${this.currentTextChannel} channel!</p>\r\n                </div>\r\n            `;\r\n            \r\n            // Load persistent chat history for this channel\r\n            if (this.globalChatHistory[this.currentTextChannel]) {\r\n                this.globalChatHistory[this.currentTextChannel].forEach(msg => {\r\n                    this.uiManager.addChatMessage(msg);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    async joinVoiceChannel(channelId) {\r\n        // FIXED: Check if already in this voice channel\r\n        if (this.currentVoiceChannel === channelId) {\r\n            this.uiManager.showNotification('Already in this voice channel', 'info');\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            console.log('Joining voice channel:', channelId);\r\n            \r\n            // Initialize audio if needed with better error handling\r\n            if (!this.audioManager.isInitialized()) {\r\n                try {\r\n                    await this.audioManager.initialize();\r\n                } catch (audioError) {\r\n                    this.uiManager.showNotification(audioError.message, 'error');\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            // Leave current voice channel if in one\r\n            if (this.currentVoiceChannel) {\r\n                this.leaveVoiceChannel(this.currentVoiceChannel);\r\n            }\r\n            \r\n            this.currentVoiceChannel = channelId;\r\n            \r\n            // Emit to server\r\n            this.connectionManager.socket.emit('join-voice-channel', { channelId });\r\n            \r\n            // Add self to voice channel participants\r\n            const username = this.settingsManager.get('username') || 'Anonymous';\r\n            const userColor = this.settingsManager.get('userColor') || 'purple';\r\n            \r\n            this.uiManager.addVoiceParticipant(this.myUserId, username, userColor, channelId, true);\r\n            \r\n            // Add self to proximity map\r\n            if (this.proximityMap) {\r\n                this.proximityMap.addUser(this.myUserId, username, true);\r\n                this.proximityMap.updateUserColor(this.myUserId, userColor);\r\n            }\r\n            \r\n            // Connect to existing voice users in this channel\r\n            this.hubUsers.forEach(user => {\r\n                if (user.userId !== this.myUserId && user.voiceChannel === channelId) {\r\n                    this.audioManager.connectToUser(user.userId, user.username, user.userColor);\r\n                    this.uiManager.addVoiceParticipant(user.userId, user.username, user.userColor, channelId, false);\r\n                }\r\n            });\r\n            \r\n            // Show leave channel button now that we're in voice\r\n            this.updateLeaveButtonVisibility();\r\n            \r\n            this.uiManager.showNotification(`Joined ${channelId} voice channel`, 'success');\r\n            \r\n        } catch (error) {\r\n            console.error('Failed to join voice channel:', error);\r\n            this.uiManager.showNotification('Failed to join voice channel. Please allow microphone access.', 'error');\r\n            this.currentVoiceChannel = null;\r\n        }\r\n    }\r\n\r\n    leaveVoiceChannel(channelId) {\r\n        console.log('Leaving voice channel:', channelId);\r\n        \r\n        if (this.currentVoiceChannel === channelId) {\r\n            // Emit to server\r\n            this.connectionManager.socket.emit('leave-voice-channel', { channelId });\r\n            \r\n            // Disconnect from all users\r\n            this.audioManager.disconnectAll();\r\n            \r\n            // Clear voice UI\r\n            this.uiManager.removeVoiceParticipant(this.myUserId, channelId);\r\n            \r\n            if (this.proximityMap) {\r\n                this.proximityMap.clearUsers();\r\n            }\r\n            \r\n            this.currentVoiceChannel = null;\r\n            \r\n            // Hide leave channel button\r\n            this.updateLeaveButtonVisibility();\r\n            \r\n            this.uiManager.showNotification(`Left ${channelId} voice channel`, 'info');\r\n        }\r\n    }\r\n\r\n    // FIXED: Update leave button visibility based on voice channel status\r\n    updateLeaveButtonVisibility() {\r\n        const leaveChannelBtn = document.getElementById('leaveChannelBtn');\r\n        const mapLeaveChannelBtn = document.getElementById('mapLeaveChannelBtn');\r\n        \r\n        const shouldShow = this.currentVoiceChannel !== null;\r\n        \r\n        if (leaveChannelBtn) {\r\n            leaveChannelBtn.style.display = shouldShow ? 'block' : 'none';\r\n        }\r\n        if (mapLeaveChannelBtn) {\r\n            mapLeaveChannelBtn.style.display = shouldShow ? 'block' : 'none';\r\n        }\r\n    }\r\n\r\n    handleHubUsers(users) {\r\n        this.hubUsers = users;\r\n        \r\n        // Update all voice channel participant lists\r\n        this.updateAllVoiceChannelParticipants(users);\r\n        \r\n        // If in voice channel, handle connections\r\n        if (this.currentVoiceChannel) {\r\n            // Clear proximity map and re-add users\r\n            if (this.proximityMap) {\r\n                this.proximityMap.clearUsers();\r\n                \r\n                // Re-add self\r\n                const username = this.settingsManager.get('username') || 'Anonymous';\r\n                const userColor = this.settingsManager.get('userColor') || 'purple';\r\n                this.proximityMap.addUser(this.myUserId, username, true);\r\n                this.proximityMap.updateUserColor(this.myUserId, userColor);\r\n            }\r\n            \r\n            // Add other users in the same voice channel\r\n            users.forEach(user => {\r\n                if (user.userId !== this.myUserId && user.voiceChannel === this.currentVoiceChannel) {\r\n                    this.handleUserJoined(user);\r\n                    this.audioManager.connectToUser(user.userId, user.username, user.userColor);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    updateAllVoiceChannelParticipants(users) {\r\n        // Clear all voice channel participants first\r\n        this.uiManager.clearVoiceParticipants();\r\n        \r\n        // Group users by voice channel\r\n        const usersByChannel = {};\r\n        users.forEach(user => {\r\n            if (user.voiceChannel) {\r\n                if (!usersByChannel[user.voiceChannel]) {\r\n                    usersByChannel[user.voiceChannel] = [];\r\n                }\r\n                usersByChannel[user.voiceChannel].push(user);\r\n            }\r\n        });\r\n        \r\n        // Add participants to each voice channel\r\n        Object.entries(usersByChannel).forEach(([channelId, channelUsers]) => {\r\n            channelUsers.forEach(user => {\r\n                this.uiManager.addVoiceParticipant(user.userId, user.username, user.userColor, channelId, false);\r\n            });\r\n        });\r\n        \r\n        // Add self to current voice channel if in one\r\n        if (this.currentVoiceChannel) {\r\n            const username = this.settingsManager.get('username') || 'Anonymous';\r\n            const userColor = this.settingsManager.get('userColor') || 'purple';\r\n            this.uiManager.addVoiceParticipant(this.myUserId, username, userColor, this.currentVoiceChannel, true);\r\n        }\r\n    }\r\n\r\n    handleUserJoined(user) {\r\n        // Add to current voice channel if they're in the same one\r\n        if (this.currentVoiceChannel && user.voiceChannel === this.currentVoiceChannel) {\r\n            if (this.proximityMap) {\r\n                this.proximityMap.addUser(user.userId, user.username, false);\r\n                this.proximityMap.updateUserColor(user.userId, user.userColor);\r\n            }\r\n            \r\n            // Establish WebRTC connection\r\n            this.audioManager.connectToUser(user.userId, user.username, user.userColor);\r\n        }\r\n        \r\n        // Always add to voice channel participant list if they're in a voice channel\r\n        if (user.voiceChannel) {\r\n            this.uiManager.addVoiceParticipant(user.userId, user.username, user.userColor, user.voiceChannel, false);\r\n        }\r\n    }\r\n\r\n    handleUserLeft(user) {\r\n        // Remove from all UI elements\r\n        this.uiManager.removeVoiceParticipant(user.userId);\r\n        \r\n        if (this.proximityMap) {\r\n            this.proximityMap.removeUser(user.userId);\r\n        }\r\n        \r\n        this.audioManager.disconnectFromUser(user.userId);\r\n    }\r\n\r\n    handlePageChange(page) {\r\n        // FIXED: Don't affect voice channel when switching pages\r\n        if (page === 'map' && this.proximityMap) {\r\n            this.proximityMap.resizeCanvas();\r\n        }\r\n        \r\n        if (page === 'settings') {\r\n            // FIXED: Prevent device switching on page change\r\n            this.isPopulatingDevices = true;\r\n            this.uiManager.populateAudioDevices().then(() => {\r\n                // Restore saved devices\r\n                const savedInputDevice = this.settingsManager.get('audioInputDevice');\r\n                const savedOutputDevice = this.settingsManager.get('audioOutputDevice');\r\n                \r\n                if (savedInputDevice) {\r\n                    const inputSelect = document.getElementById('audioDevice');\r\n                    if (inputSelect) inputSelect.value = savedInputDevice;\r\n                }\r\n                \r\n                if (savedOutputDevice) {\r\n                    const outputSelect = document.getElementById('audioOutputDevice');\r\n                    if (outputSelect) outputSelect.value = savedOutputDevice;\r\n                }\r\n                \r\n                this.isPopulatingDevices = false;\r\n            });\r\n            \r\n            this.audioManager.startPersistentVisualizer();\r\n        } else {\r\n            this.audioManager.stopPersistentVisualizer();\r\n        }\r\n    }\r\n\r\n    // FIXED: Leave channel functionality - only leaves voice, not hub\r\n    leaveCurrentChannel() {\r\n        console.log('Leave channel called, current state:', {\r\n            isInHub: this.isInHub,\r\n            currentVoiceChannel: this.currentVoiceChannel\r\n        });\r\n        \r\n        if (!this.isInHub) {\r\n            this.uiManager.showNotification('Not in any channel', 'warning');\r\n            return;\r\n        }\r\n        \r\n        if (this.currentVoiceChannel) {\r\n            // Leave voice channel only\r\n            console.log('Leaving voice channel...');\r\n            this.leaveVoiceChannel(this.currentVoiceChannel);\r\n            \r\n            // Update UI to remove voice channel selection\r\n            this.uiManager.updateVoiceChannelUI(null);\r\n        } else {\r\n            this.uiManager.showNotification('Not in a voice channel', 'info');\r\n        }\r\n    }\r\n\r\n    updateParticipantName() {\r\n        const newUsername = this.settingsManager.get('username') || 'Anonymous';\r\n        \r\n        // Update in voice participants\r\n        if (this.currentVoiceChannel) {\r\n            const channelKey = this.currentVoiceChannel.replace('-voice', '');\r\n            const voiceParticipant = document.getElementById(`voice-participant-${this.myUserId}-${channelKey}`);\r\n            if (voiceParticipant) {\r\n                const nameSpan = voiceParticipant.querySelector('span:last-child');\r\n                if (nameSpan) {\r\n                    nameSpan.textContent = newUsername;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Update in proximity map\r\n        if (this.proximityMap && this.myUserId) {\r\n            const user = this.proximityMap.users.get(this.myUserId);\r\n            if (user) {\r\n                user.username = newUsername;\r\n            }\r\n        }\r\n    }\r\n\r\n    updateParticipantColor() {\r\n        const newColor = this.settingsManager.get('userColor');\r\n        \r\n        if (this.proximityMap && this.myUserId) {\r\n            this.proximityMap.updateUserColor(this.myUserId, newColor);\r\n        }\r\n        \r\n        // Update voice participant avatar\r\n        if (this.currentVoiceChannel) {\r\n            const channelKey = this.currentVoiceChannel.replace('-voice', '');\r\n            const voiceParticipant = document.getElementById(`voice-participant-${this.myUserId}-${channelKey}`);\r\n            if (voiceParticipant) {\r\n                const avatar = voiceParticipant.querySelector('.participant-avatar');\r\n                if (avatar) {\r\n                    avatar.textContent = this.uiManager.getColorEmoji(newColor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async testMicrophone() {\r\n        try {\r\n            if (!this.audioManager.isInitialized()) {\r\n                await this.audioManager.initialize();\r\n            }\r\n            \r\n            await this.audioManager.testMicrophone();\r\n            this.uiManager.showNotification('Microphone test - speak now! üé§', 'info');\r\n            \r\n            setTimeout(() => {\r\n                this.uiManager.showNotification('Microphone test complete!', 'success');\r\n            }, 10000);\r\n            \r\n        } catch (error) {\r\n            console.error('Error testing microphone:', error);\r\n            this.uiManager.showNotification('Failed to test microphone: ' + error.message, 'error');\r\n        }\r\n    }\r\n\r\n    async testOutput() {\r\n        try {\r\n            await this.audioManager.testOutput();\r\n            this.uiManager.showNotification('Playing test sound...', 'info');\r\n        } catch (error) {\r\n            this.uiManager.showNotification('Failed to play test sound', 'error');\r\n        }\r\n    }\r\n\r\n    // Public methods for other managers to use\r\n    sendPositionUpdate(x, y) {\r\n        if (this.connectionManager.socket && this.isInHub && this.currentVoiceChannel) {\r\n            this.connectionManager.socket.emit('position-update', {\r\n                roomId: this.currentVoiceChannel,\r\n                x, y\r\n            });\r\n        }\r\n    }\r\n\r\n    updateMicStatus(isMuted) {\r\n        if (this.connectionManager.socket && this.isInHub && this.currentVoiceChannel) {\r\n            this.connectionManager.socket.emit('mic-status', {\r\n                roomId: this.currentVoiceChannel,\r\n                isMuted\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n// Initialize app when DOM is ready\r\nfunction initApp() {\r\n    try {\r\n        window.proximityApp = new ProximityApp();\r\n        console.log('App initialized successfully');\r\n    } catch (error) {\r\n        console.error('Error initializing app:', error);\r\n    }\r\n}\r\n\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initApp);\r\n} else {\r\n    initApp();\r\n}"],"names":[],"sourceRoot":""}